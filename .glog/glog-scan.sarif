{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "614e7e2e-f37f-3862-ada9-97b129700396",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "69528974-9557-3af4-b1d6-e65e3faca3c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. Additionally, the source pointer may be null at this location, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination is not confirmed to be a pointer-based member, making the risk more pronounced. The count argument is not derived from the destination's capacity, and there is no evidence of a null-terminator being set after the operation. All these factors indicate a real and actionable issue that should be addressed to prevent potential security and stability problems.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```c\nmemmove(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy:\n\n```c\nif (g_props[NodeId].link != NULL) {\n    memmove(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "de3d036a-fa99-3cd3-b5d7-6949c6bc7e8e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "900eaf87-52d6-3975-95f7-702bb2bdafaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or other security issues if the environment variable contains sensitive information.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. If you must use a potentially insecure function, make sure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nchar* temp = std::getenv(per_node_override);\nif(temp != nullptr)\n    envvar = temp;\nelse {\n    temp = std::getenv(\"HSA_OVERRIDE_GFX_VERSION\");\n    if(temp != nullptr)\n        envvar = temp;\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "900eaf87-52d6-3975-95f7-702bb2bdafaa"
                ]
              }
            },
            {
              "id": "c89176f3-6bcb-3726-9ca2-c0d728e38099",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or other security issues if the environment variable contains sensitive information.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. If you must use a potentially insecure function, make sure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nchar* temp = std::getenv(per_node_override);\nif(temp != nullptr)\n    envvar = temp;\nelse {\n    temp = std::getenv(\"HSA_OVERRIDE_GFX_VERSION\");\n    if(temp != nullptr)\n        envvar = temp;\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "c89176f3-6bcb-3726-9ca2-c0d728e38099"
                ]
              }
            },
            {
              "id": "8d42967b-3f84-3ec3-b570-8e989712fe84",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4c0fc642-84ab-3857-b748-1f90f6652957",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (sizeof(cpuinfo[proc].model_name) >= p_len) {\n    memcpy(cpuinfo[proc].model_name, p, p_len);\n} else {\n    // Handle error: source is too large for destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest and most trusted resources for secure coding practices."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "30bb7a0c-8094-306f-8808-ce7f29b60266",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy()`, `strcat()`, and `strlen()`. Consider using safer alternatives that take the size of the buffer as a parameter, such as `strncpy()`, `strncat()`, and `strnlen()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(p)`, use `strnlen(p, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the buffer.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar p[MAX_LEN];\n\n// ... populate p with a string ...\n\nsize_t len = strnlen(p, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C and the `<cstring>` library in C++.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "91f26a41-7666-3622-9d5a-f523115909bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used properly. In the provided code snippet, the `strlen(p) - 1` could potentially lead to a buffer underflow if the string `p` is empty. This is because `strlen(p)` would return 0 for an empty string, and subtracting 1 from it would result in -1, which is an invalid index.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in an array index. This can prevent buffer underflow and overflow vulnerabilities. Additionally, it is also recommended to use safer string handling functions that are bounds-checked to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (p && strlen(p) > 0) {\n    cpuinfo[proc].model_name[strlen(p) - 1] = '\\0';\n}\n```\n\nIn this fix, we first check if `p` is not null and if its length is greater than 0 before using it as an array index.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "426ae88f-c755-3104-837f-fd9b0ce29c99",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used correctly. In the provided code snippet, `strlen(p) - 1` is used as the length parameter for `strncpy()`. If the string `p` is empty, `strlen(p) - 1` will result in a large unsigned integer due to underflow, which can lead to buffer overflow when used in `strncpy()`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in functions like `strncpy()`. Also, it is a good practice to use safer string handling functions that automatically handle the null-terminating character and prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strlen(p);\nif (len > 0) {\n    strncpy(cpuinfo[proc].model_name, p, len - 1);\n    cpuinfo[proc].model_name[len - 1] = '\\0';\n} else {\n    cpuinfo[proc].model_name[0] = '\\0';\n}\n```\n\nIn this fix, we first check if the length of the string `p` is greater than 0. If it is, we proceed with the `strncpy()` operation and ensure that the destination string is null-terminated. If the length of `p` is 0, we simply set the first character of the destination string to the null character.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `cstring` or `string.h` for `strlen()` and `strncpy()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f8a5c755-347b-37e9-a6a0-c3cae1530489",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a245924f-4407-3779-9db4-e8cb4ceb6389",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can lead to a security risk. In this case, the function `atoi()` is used, which converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the string cannot be converted to an integer, it returns zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace the `atoi()` function with a function that performs error checking, such as `strtol()`. This function allows you to check if the entire string was converted to an integer and if any errors occurred during the conversion.\n\n## Source Code Fix Recommendation\n\nHere is how you can replace `atoi()` with `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *p;\nlong int proc;\nchar *endptr;\n\nerrno = 0;    /* To distinguish success/failure after call */\nproc = strtol(p, &endptr, 10);\n\n/* Check for various possible errors */\n\nif ((errno == ERANGE && (proc == LONG_MAX || proc == LONG_MIN))\n        || (errno != 0 && proc == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == p) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n/* If we got here, strtol() successfully parsed a number */\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5925c749-7dbf-3038-8010-60eadb3a2ac5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if not used properly. \n\nThe `fopen` function is used to open a file, but it does not check if the operation succeeded or not. If the file does not exist or cannot be accessed for some reason, the function will return a NULL pointer, which can lead to undefined behavior if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the return value of `fopen` and handle the error appropriately. This can prevent undefined behavior and potential security issues.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nFILE* fd = fopen(proc_cpuinfo_path, \"r\");\nif (fd == NULL) {\n    // Handle error appropriately\n    perror(\"Error opening file\");\n    return;\n}\n```\n\nIn this fixed code, the return value of `fopen` is checked and if it is NULL, an error message is printed and the function returns.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `stdio.h`: This library is required for the `fopen` function.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fefc2180-ca00-3d29-806b-78df341f3d32",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function as it does not check for errors. Instead, use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent any malicious data from causing harm.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is the fixed code:\n\n```cpp\nchar *end;\nlong proc_num = strtol(p, &end, 10);\nif (end == p || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    this_cpu->proc_num = proc_num;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable program behavior. Additionally, there is no evidence of a guard to prevent the source from being null, which further increases the risk. The destination is not likely to be null, but the main concern is the potential for overlapping memory regions. The verdict is supported by the classification and the explicit 'GENUINE' verdict from the analysis.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that safely handles overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```c\nmemmove(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n```\n\n## References\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination do not overlap. If you can guarantee non-overlapping regions by design, add an explicit assertion or guard to document and enforce this assumption:\n\n```c\nassert((char *)&tbl->cache[cache_cnt] + sizeof(HsaCacheProperties) <= (char *)this_cache ||\n       (char *)this_cache + sizeof(HsaCacheProperties) <= (char *)&tbl->cache[cache_cnt]);\nmemcpy(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n```\n\nThis assertion will catch accidental overlaps during development and testing.\n\n## References\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p) < HSA_PUBLIC_NAME_SIZE` vulnerability in C++ programming language is a potential buffer overflow vulnerability. This occurs when the length of the string pointed to by `p` is less than `HSA_PUBLIC_NAME_SIZE`. If an attacker can control the input to `p`, they can potentially cause a buffer overflow, leading to arbitrary code execution, application crashes, or other security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the buffer is sufficient to hold the data being copied into it. This includes the null-terminating character for strings. You should also validate and sanitize all input, especially if it comes from an untrusted source.\n\n## Source Code Fix Recommendation\n\nA potential fix for this vulnerability would be to use the `strncpy` function instead of `strlen`. This function allows you to specify the maximum number of characters to be copied, preventing a buffer overflow. Here is an example:\n\n```cpp\nchar p[HSA_PUBLIC_NAME_SIZE];\nstrncpy(p, input, HSA_PUBLIC_NAME_SIZE - 1);\np[HSA_PUBLIC_NAME_SIZE - 1] = '\\0';\n```\n\nIn this example, `input` is the string to be copied into `p`. The `strncpy` function copies at most `HSA_PUBLIC_NAME_SIZE - 1` characters, leaving room for the null-terminating character. The last line ensures that the string is properly null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "53ad4208-6dae-3658-9f0e-e447d212d367",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e226928f-9961-33b5-9e79-3fc4fe5cae72",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path or mode string is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to implement proper validation and error handling. In the case of `fopen`, consider using a function that allows for more control over file permissions, or ensure that the file path and mode string are properly validated and controlled.\n\n## Source Code Fix Recommendation\n\n```cpp\n#define KFD_SYSFS_PATH_SYSTEM_PROPERTIES \"/sys/class/kfd/kfd/topology/system_properties\"\n\nFILE *fd;\nif((fd = fopen(KFD_SYSFS_PATH_SYSTEM_PROPERTIES, \"r\")) == NULL) {\n    // Handle error\n    printf(\"Error opening file\\n\");\n    return -1;\n}\n```\n\nIn this code, the `fopen` function is used to open a file, and the return value is checked to ensure that the file was successfully opened. If `fopen` returns `NULL`, an error message is printed and the function returns -1.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ebea03cb-c3f6-371b-8288-682e5632a34d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2117bcff-d427-37cf-b636-5421cf45520f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the `strtok` function is used, which is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strtok`. Instead, use thread-safe alternatives such as `strtok_r` or `strtok_s`. Also, consider using higher-level string parsing functions provided by the C++ Standard Library, which are generally safer and less prone to errors.\n\n## Source Code Fix\n\nReplace the `strtok` function with a thread-safe alternative. Here's an example of how you can do this:\n\n```cpp\nchar *saveptr;\nch_ptr = strtok_r(shared_cpu_map, \",\", &saveptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d5c7df64-e41e-3374-a065-10641c23a548",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8699a82-1be9-325d-a21c-4236b8ca73da",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fopen`, consider using `fopen_s` which is a safer version of `fopen`. It's also important to always check the return value of `fopen` to ensure that the file was opened successfully.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the provided code snippet:\n\n```cpp\nerrno_t err;\n\nerr = fopen_s(&fd, KFD_SYSFS_PATH_GENERATION_ID, \"r\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdio.h`: for `fopen` function\n- `errno.h`: for `errno_t` type\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "64b0ab60-1ced-322c-b8b6-eb2068181656",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the `strtok` function is used, which is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strtok`. Instead, use thread-safe alternatives such as `strtok_r` or `strtok_s` if available. Also, consider using higher-level string parsing functions provided by the C++ Standard Library, which are generally safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strtok` function with a thread-safe alternative. Here is an example using `strtok_r`:\n\n```cpp\nchar *saveptr;\nch_ptr = strtok_r(NULL, \",\", &saveptr);\n```\n\n## Library Dependencies\n\nThe code example requires the C Standard Library (`<cstring>` in C++).\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, it can lead to a buffer overflow vulnerability if the string is not null-terminated. In the provided code snippet, `strlen(shared_cpu_map)` could potentially lead to a buffer overflow if `shared_cpu_map` is not null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strnlen(shared_cpu_map, MAX_LENGTH);\nnum_hexs = (len + 8) / 9;\n```\n\nIn this fix, `strnlen` is used instead of `strlen` and `MAX_LENGTH` is a predefined constant that specifies the maximum length of `shared_cpu_map`.\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly indicate any library dependencies. However, the `strlen` function is part of the C Standard Library (`<cstring>` in C++).\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e5642ce5-79ec-34d2-9d94-61c04b5b13f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5809fe15-4dd1-35b8-9bbc-b4e4bf5a6250",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate the string for you.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nprefix_len = strlen(prefix);\n```\n\nYou could use:\n\n```cpp\nprefix_len = strnlen(prefix, MAX_PREFIX_LEN);\n```\n\nWhere `MAX_PREFIX_LEN` is the maximum expected length of the prefix.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict for this call site is marked as genuine. The code copies memory from a function result to a destination pointer, but there are no visible checks to ensure that the source pointer returned by the function is not null. The analysis also conservatively reports that the source may be null, which could lead to a crash or other undefined behavior if memcpy is called with a null source. The destination is less likely to be null, as it is not a pointer-based member and is likely a local or field array. There is no evidence of buffer overlap, and the count expression is not directly tied to the destination's capacity, increasing the risk if the source or destination is not properly validated. No explicit null-termination or guard conditions are present.\n\n## In Context Remediation\nBefore copying memory, ensure that both the source and destination pointers are not null. Add explicit checks before the memory copy operation to prevent undefined behavior if either pointer is null. For example:\n\n```c\nif (queue_ptr != NULL) {\n    void *src = convert_queue_ids(num_queues, Queues);\n    if (src != NULL) {\n        memcpy(queue_ptr, src, num_queues * sizeof(uint32_t));\n    } else {\n        // Handle error: source is null\n    }\n} else {\n    // Handle error: destination is null\n}\n```\n\nThis ensures that memcpy is only called with valid pointers, preventing crashes or undefined behavior.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "30cefb5e-6d04-3d68-9853-92409d953d79",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to potential issues if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv` function directly without proper validation and error checking. If you must use it, ensure that the returned value is not null before using it. Also, be aware that the returned string may be modified by subsequent calls to `getenv`, `setenv`, or `putenv`.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar* maxVaAlignStr = getenv(\"HSA_MAX_VA_ALIGN\");\nif(maxVaAlignStr == NULL) {\n    // Handle the error, e.g., by using a default value\n    maxVaAlignStr = \"default_value\";\n}\n```\n\n## Library Dependencies\n\nThe `getenv` function is part of the C Standard Library (libc), so no additional libraries are required.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "867a2739-0b84-34c7-a9b3-fad7bee50348",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the following factors: the classification explicitly states a risk of undefined behavior from overlapping memory regions, and the automated assessment marked this as a genuine issue. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, there are no checks ensuring that the source and destination are non-null, which increases the risk of null pointer dereference. No explicit bounds or guards are present to mitigate these risks. Developers should address both the overlap and null pointer risks to ensure safe and predictable behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use a memory move function that safely handles overlapping regions. Additionally, ensure that both the source and destination pointers are checked for null before performing the operation. For example:\n\n```c\nif (importArgs.share_handle != NULL && SharedMemoryStruct != NULL && SharedMemoryStruct->ShareHandle != NULL) {\n    memmove(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n}\n```\nThis approach uses `memmove` instead of `memcpy`, which is safe for overlapping memory regions, and adds null pointer checks to prevent dereferencing null pointers. \n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "eca34812-b7c8-3a0e-a779-3d5eacb2aa7f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `getenv` is used, which can lead to security vulnerabilities as it returns a pointer to a string that represents the value for the environment variable passed as input. This string can be altered by an attacker, leading to potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using the `getenv` function. Instead, use safer alternatives that do not have the same vulnerabilities. For example, consider using a function that copies the environment variable into a buffer that you control, so that you can ensure that it is not overwritten by an attacker.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how you can modify the code:\n\n```cpp\nchar* reserveSvm;\nsize_t requiredSize;\ngetenv_s(&requiredSize, NULL, 0, \"HSA_RESERVE_SVM\");\nif (requiredSize == 0)\n{\n    printf(\"HSA_RESERVE_SVM not found\\n\");\n    exit(1);\n}\nreserveSvm = (char*)malloc(requiredSize * sizeof(char));\ngetenv_s(&requiredSize, reserveSvm, requiredSize, \"HSA_RESERVE_SVM\");\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `getenv` and `exit` functions\n- `stdio.h` for `printf` function\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cd5982ad-651e-3147-b69c-c88d71b409aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that represents the value for the environment variable passed as input. If an attacker can control the environment, they can manipulate the output of this function.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a method that does not allow an attacker to control the environment.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nconst char* checkUserptr = std::getenv(\"HSA_CHECK_USERPTR\");\nif (checkUserptr == nullptr) {\n    // Handle the case where the environment variable is not set.\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "48128d6d-353f-3c70-8f68-a71cdc93f5c5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prohibited because they can lead to various security issues such as buffer overflows, format string vulnerabilities, or other types of memory corruption. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities.\n\nThe `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This function is not thread-safe and can lead to race conditions. Moreover, the returned pointer might be invalidated or the string content might be overwritten by subsequent calls to `getenv`, `setenv`, or `unsetenv`.\n\n## Mitigation Advice\n\nAvoid using `getenv` function. If you need to use environment variables, consider using a thread-safe and reentrant function. Also, ensure that the environment variable is not controlled by an untrusted user to prevent potential security risks.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nchar* pagedUserptr;\nchar* envVar = std::getenv(\"HSA_USERPTR_FOR_PAGED_MEM\");\nif(envVar != nullptr)\n{\n    pagedUserptr = strdup(envVar);\n}\n```\n\nIn this code, we use `std::getenv` which is a safer version of `getenv`. We also check if the returned pointer is not null before using it.\n\n## Library Dependencies\n\nThe code requires the `cstdlib` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no explicit check to ensure that the source is not null, which further increases the risk. The destination is not a pointer-based member, reducing the risk of it being null, but the overlap and potential null source pointer are significant concerns. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```c\nif (ids_array != NULL) {\n    memmove(&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)], ids_array, ids_array_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d0d81761-f442-3181-952c-25f46e587e08",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to potential issues if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using the `getenv` function. If you need to use environment variables, consider using a safer alternative that does not have the same vulnerabilities. Validate all input and never trust data from untrusted sources. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a safer alternative. For example, you could use the `std::getenv` function from the C++ standard library, which is considered safer:\n\n```cpp\n#include <cstdlib>\n\nconst char* guardPagesStr = std::getenv(\"HSA_SVM_GUARD_PAGES\");\nif (!guardPagesStr) {\n    // Handle the case where the environment variable is not set\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstdlib`\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable results or program crashes, as the standard memory copy function does not handle overlapping regions safely. The risk is further confirmed by the explicit classification and verdict. There are no indications that the source or destination pointers are null, and there are no explicit guards or null-terminations present. The destination is a pointer type, and the size calculation is not directly tied to a known buffer capacity, increasing the risk of incorrect memory operations.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory-safe function that handles overlapping regions correctly. Replace the standard memory copy function with a function designed for overlapping memory, such as `memmove`. This ensures that the copy operation is performed safely, even if the source and destination regions overlap.\n\n```c\nmemmove(process_apertures, args_old.process_apertures, sizeof(*process_apertures) * *num_of_nodes);\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3fc850f2-be94-3c63-b81f-d93e57e19f6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "943d24b2-b801-3716-aaa2-0158eac068aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "26278970-c011-3c6c-aecc-cf13aa48a718",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may refer to overlapping memory regions, which can cause unpredictable results with functions like memcpy. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. No explicit bounds or guards are present to mitigate these risks. These factors indicate a real and actionable issue that should be addressed to prevent potential security and stability problems.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Also, add explicit checks to ensure that both the source and destination pointers are not null before the operation to prevent null pointer dereference.\n\n```c\nif (SharedMemoryStruct->ShareHandle != NULL && exportArgs.share_handle != NULL) {\n    // Use memmove if overlap is possible\n    memmove(SharedMemoryStruct->ShareHandle, exportArgs.share_handle, sizeof(SharedMemoryStruct->ShareHandle));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause unpredictable results when using functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms this as a genuine issue. Additionally, the source and destination are not null at the call site, so the main risk is the potential for overlapping memory regions, which is not handled by memcpy and can lead to data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```c\nmemmove(attrs, args->attrs, s_attr);\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ba3d4613-16f8-3bf9-ba24-d38657d988bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "58ab4d8e-ec12-3df3-a740-b80deb4cf35b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `getenv()` is used, which can lead to security vulnerabilities if not used carefully. This function returns a pointer to a string that represents the value of the environment variable passed as input. If an attacker can modify this environment variable, they can control the output of the `getenv()` function, leading to potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv()` function if possible. If you must use it, ensure that you validate and sanitize its output before using it. Never trust the output of `getenv()` without validation, as it can be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv()`, consider using a safer alternative that allows for error handling or bounds checking. If you must use `getenv()`, validate its output before using it. Here's an example of how you might do this:\n\n```cpp\nconst char* disableCache = getenv(\"HSA_DISABLE_CACHE\");\nif (disableCache == NULL) {\n    // Handle error: environment variable not found\n} else {\n    // Validate and sanitize disableCache before using it\n}\n```\n\n## Library Dependencies\n\nThe `getenv()` function is part of the C standard library, so you'll need to include `cstdlib` to use it:\n\n```cpp\n#include <cstdlib>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The verdict is supported by the high-confidence classification and the explicit 'GENUINE' verdict from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\nThis change ensures safe copying even if the memory regions overlap and prevents null pointer dereference. Always validate the size parameter (`s_attr`) to ensure it does not exceed the capacity of the destination buffer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "875b8707-13df-33f0-9548-f0b927d5ba5f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination expressions are both identifiers, and dataflow analysis indicates that they may refer to overlapping memory. Additionally, there are no checks in place to ensure that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The absence of explicit bounds or capacity checks for the destination buffer further increases the risk. These factors together indicate a high likelihood of a real issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it prevents null pointer dereference. Also, consider validating that `s_attr` does not exceed the capacity of the destination buffer to avoid buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "407d9301-f127-36b4-b584-29bfc2978455",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "40bcd266-2384-3785-9486-008baf1aa5fa",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The absence of explicit bounds or capacity checks for the destination buffer further increases the risk. The verdict is supported by the high-confidence classification and the explicit 'GENUINE' verdict from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation. Example remediation:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap and prevents null pointer dereference. Always validate the size parameter (`s_attr`) to ensure it does not exceed the capacity of the destination buffer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ae7e02d7-0f9d-3fe1-90c8-595f3f1d3085",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fb423e8e-785a-389f-8aca-3653f0cd57fa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "117d0fc3-c62d-37ee-8ce0-7a0c39849d19",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to potential security risks. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or even code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a safer method to retrieve environment variables. Also, always validate and sanitize all inputs, even those coming from seemingly safe sources like environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nstd::string useSvmStr;\nchar* p = std::getenv(\"HSA_USE_SVM\");\nif(p!=NULL)\n    useSvmStr = std::string(p);\n```\n\nIn this code, we are still using `getenv` but in a safer way by checking if the returned pointer is not NULL before using it.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3716c81a-54dd-322b-b4fa-2740a8302451",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `alloca()` function is used, which is considered unsafe because it allocates memory on the stack, which can lead to stack overflow if the size is too large.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions are safer because they do not risk a stack overflow. However, remember to always check the return value of these functions to ensure that the memory allocation was successful, and always free the memory when you're done using it to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how you can do it:\n\n```cpp\n// Old code\nattrs = (HSA_SVM_ATTRIBUTE *)alloca(s_attr);\n\n// New code\nattrs = (HSA_SVM_ATTRIBUTE *)malloc(s_attr);\nif (attrs == NULL) {\n    // Handle error\n}\n// Remember to free the memory when you're done\nfree(attrs);\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc()` and `free()` functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "43cd1858-3aac-3158-a8fe-6cb41d1e44cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. If the input string is not a valid integer, it will return 0, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int debug_level = strtol(envvar, &end, 10);\nif (end == envvar || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdlib` (for `strtol()` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6af1b7fe-0ed1-30ec-aa8f-3e20614c5606",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is associated with the matched environment variable name. If the environment variable is controlled by an attacker, it can lead to serious security issues.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a safer function to retrieve environment variables. Validate the input and output of these functions to ensure they do not contain any malicious values.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nconst char* envvar = std::getenv(\"HSAKMT_DEBUG_LEVEL\");\nif (envvar != nullptr) {\n    // Use the value of envvar\n}\n```\n\nIn this code, we are still using `getenv()` function, but we are checking if it returns a null pointer before using the value. This can prevent null pointer dereference issues. However, this does not completely mitigate the risk if the environment variable can be controlled by an attacker.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b3e8ea2-386b-379a-bd94-b6f7e96fd72a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to undefined behavior if the string cannot be converted to an integer.\n\n## Mitigation Advice\n\nAvoid using the `atoi()` function. Instead, use functions that perform error checking such as `strtol()`. Always validate and sanitize input before processing it. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the corrected code:\n\n```cpp\n#include <cstdlib> // for strtol and NULL\n#include <climits> // for LONG_MIN and LONG_MAX\n\nchar *end;\nlong zfb_support;\nerrno = 0;\n\nzfb_support = strtol(envvar, &end, 10);\n\nif ((errno == ERANGE && (zfb_support == LONG_MAX || zfb_support == LONG_MIN))\n    || (errno != 0 && zfb_support == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (end == envvar) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- climits\n- cstdio\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6d9201b9-faac-3699-b707-2be3632c3192",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if the environment variable it retrieves is controlled by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a method that validates the environment variable before using it.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nconst char* tmp = std::getenv(\"HSA_ZFB\");\nif(tmp != nullptr) {\n    envvar = tmp;\n}\n```\n\nIn this code, `std::getenv` is used instead of `getenv`. It also checks if the environment variable is not null before assigning it to `envvar`.\n\n## Library Dependencies\n\nThe code requires the following library dependencies:\n\n- cstdlib\n- string\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the destination pointer is always valid, which increases the risk of a crash or further undefined behavior. The source is confirmed to be non-null before the call, but the destination may be null. The count argument is not directly tied to the size of the destination buffer, and there are no explicit guards or null-termination after the copy. All these factors contribute to a high-confidence, actionable issue that should be addressed to prevent memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```c\nmemmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n```\n\nAdditionally, ensure that both `q->cu_mask` and `QueueCUMask` are valid pointers and that the destination buffer is large enough to hold `CUMaskCount / 8` bytes. If there is any chance that the destination pointer could be null, add a check before the call:\n\n```c\nif (q->cu_mask != NULL && QueueCUMask != NULL) {\n    memmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "614e7e2e-f37f-3862-ada9-97b129700396",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1634,
                  "startColumn": 6,
                  "endLine": 1634,
                  "endColumn": 11,
                  "charOffset": 49008,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "69528974-9557-3af4-b1d6-e65e3faca3c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 1,
                  "endLine": 2394,
                  "endColumn": 46,
                  "charOffset": 70810,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                    "rendered": {
                      "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                      "markdown": "`memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70810,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(IoLinkProperties, <size of IoLinkProperties>,  g_props[NodeId].link, \n\t       NumIoLinks * sizeof(*IoLinkProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "de3d036a-fa99-3cd3-b5d7-6949c6bc7e8e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1298,
                  "startColumn": 6,
                  "endLine": 1298,
                  "endColumn": 11,
                  "charOffset": 38756,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8d42967b-3f84-3ec3-b570-8e989712fe84",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1095,
                  "startColumn": 6,
                  "endLine": 1095,
                  "endColumn": 11,
                  "charOffset": 31141,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4c0fc642-84ab-3857-b748-1f90f6652957",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 26,
                  "endLine": 997,
                  "endColumn": 30,
                  "charOffset": 28797,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 988,
                  "startColumn": 3,
                  "endLine": 988,
                  "endColumn": 45,
                  "charOffset": 28528,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                    "rendered": {
                      "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                      "markdown": "`memcpy(cpuinfo[proc].model_name, p, p_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28528,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cpuinfo[proc].model_name, <size of cpuinfo[proc].model_name>,  p,  p_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "30bb7a0c-8094-306f-8808-ce7f29b60266",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 985,
                  "startColumn": 11,
                  "endLine": 985,
                  "endColumn": 20,
                  "charOffset": 28443,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91f26a41-7666-3622-9d5a-f523115909bd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 962,
                  "startColumn": 10,
                  "endLine": 962,
                  "endColumn": 14,
                  "charOffset": 27838,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 29,
                  "endLine": 944,
                  "endColumn": 38,
                  "charOffset": 27286,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "426ae88f-c755-3104-837f-fd9b0ce29c99",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 943,
                  "startColumn": 41,
                  "endLine": 943,
                  "endColumn": 50,
                  "charOffset": 27241,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f8a5c755-347b-37e9-a6a0-c3cae1530489",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1533,
                  "startColumn": 6,
                  "endLine": 1533,
                  "endColumn": 11,
                  "charOffset": 45857,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a245924f-4407-3779-9db4-e8cb4ceb6389",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 10,
                  "endLine": 919,
                  "endColumn": 14,
                  "charOffset": 26617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5925c749-7dbf-3038-8010-60eadb3a2ac5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 6,
                  "endLine": 898,
                  "endColumn": 11,
                  "charOffset": 25994,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fefc2180-ca00-3d29-806b-78df341f3d32",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1448,
                  "startColumn": 23,
                  "endLine": 1448,
                  "endColumn": 27,
                  "charOffset": 43524,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1499,
                  "startColumn": 3,
                  "endLine": 1501,
                  "endColumn": 36,
                  "charOffset": 45055,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                    "rendered": {
                      "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                      "markdown": "`memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45055,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tbl->cache[cache_cnt++], <size of &tbl->cache[cache_cnt++]>, \n\t\t\t       this_cache, \n\t\t\t       sizeof(HsaCacheProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 7,
                  "endLine": 941,
                  "endColumn": 16,
                  "charOffset": 27131,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "53ad4208-6dae-3658-9f0e-e447d212d367",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 614,
                  "startColumn": 6,
                  "endLine": 614,
                  "endColumn": 11,
                  "charOffset": 18507,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e226928f-9961-33b5-9e79-3fc4fe5cae72",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 723,
                  "startColumn": 6,
                  "endLine": 723,
                  "endColumn": 11,
                  "charOffset": 21212,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ebea03cb-c3f6-371b-8288-682e5632a34d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 666,
                  "startColumn": 6,
                  "endLine": 666,
                  "endColumn": 11,
                  "charOffset": 19939,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2117bcff-d427-37cf-b636-5421cf45520f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 468,
                  "startColumn": 10,
                  "endLine": 468,
                  "endColumn": 16,
                  "charOffset": 14048,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d5c7df64-e41e-3374-a065-10641c23a548",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 420,
                  "startColumn": 6,
                  "endLine": 420,
                  "endColumn": 11,
                  "charOffset": 12834,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8699a82-1be9-325d-a21c-4236b8ca73da",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 584,
                  "startColumn": 6,
                  "endLine": 584,
                  "endColumn": 11,
                  "charOffset": 17750,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "64b0ab60-1ced-322c-b8b6-eb2068181656",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 483,
                  "startColumn": 11,
                  "endLine": 483,
                  "endColumn": 17,
                  "charOffset": 14479,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 13,
                  "endLine": 467,
                  "endColumn": 35,
                  "charOffset": 13980,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(shared_cpu_map)",
                    "rendered": {
                      "text": "strlen(shared_cpu_map)",
                      "markdown": "`strlen(shared_cpu_map)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e5642ce5-79ec-34d2-9d94-61c04b5b13f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 6,
                  "endLine": 395,
                  "endColumn": 11,
                  "charOffset": 12280,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5809fe15-4dd1-35b8-9bbc-b4e4bf5a6250",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 372,
                  "startColumn": 6,
                  "endLine": 372,
                  "endColumn": 11,
                  "charOffset": 11767,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 18,
                  "endLine": 344,
                  "endColumn": 32,
                  "charOffset": 11181,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(prefix)",
                    "rendered": {
                      "text": "strlen(prefix)",
                      "markdown": "`strlen(prefix)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 2,
                  "endLine": 532,
                  "endColumn": 57,
                  "charOffset": 14449,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                    "rendered": {
                      "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                      "markdown": "`memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14449,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(queue_ptr, <size of queue_ptr>,  convert_queue_ids(num_queues,  Queues)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "30cefb5e-6d04-3d68-9853-92409d953d79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2540,
                  "startColumn": 17,
                  "endLine": 2540,
                  "endColumn": 23,
                  "charOffset": 72602,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "867a2739-0b84-34c7-a9b3-fad7bee50348",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3817,
                  "startColumn": 1,
                  "endLine": 3818,
                  "endColumn": 34,
                  "charOffset": 111548,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                    "rendered": {
                      "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                      "markdown": "`memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111548,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(importArgs.share_handle, <size of importArgs.share_handle>,  SharedMemoryStruct->ShareHandle, \n\t\t\tsizeof(importArgs.share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eca34812-b7c8-3a0e-a779-3d5eacb2aa7f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2529,
                  "startColumn": 14,
                  "endLine": 2529,
                  "endColumn": 20,
                  "charOffset": 72182,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cd5982ad-651e-3147-b69c-c88d71b409aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2523,
                  "startColumn": 16,
                  "endLine": 2523,
                  "endColumn": 22,
                  "charOffset": 71976,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "48128d6d-353f-3c70-8f68-a71cdc93f5c5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2517,
                  "startColumn": 16,
                  "endLine": 2517,
                  "endColumn": 22,
                  "charOffset": 71744,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2962,
                  "startColumn": 1,
                  "endLine": 2964,
                  "endColumn": 29,
                  "charOffset": 85760,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                    "rendered": {
                      "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                      "markdown": "`memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85760,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)], <size of &obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)]>, \n\t\t\tids_array,  ids_array_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d0d81761-f442-3181-952c-25f46e587e08",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2533,
                  "startColumn": 17,
                  "endLine": 2533,
                  "endColumn": 23,
                  "charOffset": 72356,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1762,
                  "startColumn": 8,
                  "endLine": 1762,
                  "endColumn": 16,
                  "charOffset": 49213,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2042,
                  "startColumn": 1,
                  "endLine": 2043,
                  "endColumn": 34,
                  "charOffset": 56906,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                    "rendered": {
                      "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                      "markdown": "`memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56906,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(process_apertures, <size of process_apertures>,  args_old.process_apertures, \n\t       sizeof(*process_apertures)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fc850f2-be94-3c63-b81f-d93e57e19f6d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1038,
                  "startColumn": 8,
                  "endLine": 1038,
                  "endColumn": 14,
                  "charOffset": 28986,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "943d24b2-b801-3716-aaa2-0158eac068aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 5,
                  "endLine": 206,
                  "endColumn": 13,
                  "charOffset": 6316,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "26278970-c011-3c6c-aecc-cf13aa48a718",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 5,
                  "endLine": 202,
                  "endColumn": 13,
                  "charOffset": 6177,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3787,
                  "startColumn": 1,
                  "endLine": 3788,
                  "endColumn": 42,
                  "charOffset": 110495,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                    "rendered": {
                      "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                      "markdown": "`memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 110495,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(SharedMemoryStruct->ShareHandle, <size of SharedMemoryStruct->ShareHandle>,  exportArgs.share_handle, \n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 35,
                  "charOffset": 5079,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(attrs, args->attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(attrs, args->attrs, s_attr)",
                      "markdown": "`memcpy(attrs, args->attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5079,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(attrs, <size of attrs>,  args->attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ba3d4613-16f8-3bf9-ba24-d38657d988bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 8,
                  "endLine": 128,
                  "endColumn": 14,
                  "charOffset": 4118,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "58ab4d8e-ec12-3df3-a740-b80deb4cf35b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2511,
                  "startColumn": 16,
                  "endLine": 2511,
                  "endColumn": 22,
                  "charOffset": 71506,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 35,
                  "charOffset": 4275,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4275,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "875b8707-13df-33f0-9548-f0b927d5ba5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 1,
                  "endLine": 67,
                  "endColumn": 35,
                  "charOffset": 2209,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2209,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "407d9301-f127-36b4-b584-29bfc2978455",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1073,
                  "startColumn": 8,
                  "endLine": 1073,
                  "endColumn": 14,
                  "charOffset": 30148,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "40bcd266-2384-3785-9486-008baf1aa5fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 1,
                  "endLine": 252,
                  "endColumn": 35,
                  "charOffset": 6680,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6680,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ae7e02d7-0f9d-3fe1-90c8-595f3f1d3085",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 8,
                  "endLine": 247,
                  "endColumn": 14,
                  "charOffset": 6514,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fb423e8e-785a-389f-8aca-3653f0cd57fa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 14,
                  "charOffset": 2052,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "117d0fc3-c62d-37ee-8ce0-7a0c39849d19",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 14,
                  "endLine": 196,
                  "endColumn": 20,
                  "charOffset": 5074,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 549,
                  "startColumn": 11,
                  "endLine": 549,
                  "endColumn": 19,
                  "charOffset": 14844,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3716c81a-54dd-322b-b4fa-2740a8302451",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 30,
                  "endLine": 439,
                  "endColumn": 36,
                  "charOffset": 11571,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "43cd1858-3aac-3158-a8fe-6cb41d1e44cb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 16,
                  "endLine": 135,
                  "endColumn": 20,
                  "charOffset": 3617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6af1b7fe-0ed1-30ec-aa8f-3e20614c5606",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 10,
                  "endLine": 133,
                  "endColumn": 16,
                  "charOffset": 3556,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b3e8ea2-386b-379a-bd94-b6f7e96fd72a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 20,
                  "charOffset": 3872,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6d9201b9-faac-3699-b707-2be3632c3192",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 10,
                  "endLine": 142,
                  "endColumn": 16,
                  "charOffset": 3824,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 810,
                  "startColumn": 1,
                  "endLine": 810,
                  "endColumn": 49,
                  "charOffset": 21859,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                    "rendered": {
                      "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                      "markdown": "`memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21859,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(q->cu_mask, <size of q->cu_mask>,  QueueCUMask,  CUMaskCount / 8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}