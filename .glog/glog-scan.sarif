{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-d34082d9-b7e9-4f6f-a434-56facc4a65e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nif (NumIoLinks * sizeof(*IoLinkProperties) <= sizeof(g_props[NodeId].link)) {\n    memcpy(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-543a5ff8-6702-4bb8-9902-15cf1e7cc72a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used correctly. If the size of the memory to be allocated is not properly validated or controlled, it can lead to various security issues such as buffer overflows, memory corruption, or denial of service attacks.\n\nIn the given code snippet, `malloc(sizeof(HsaSystemProperties))`, the vulnerability could arise if the size of `HsaSystemProperties` is not properly controlled or if the return value of `malloc` is not checked for null (which indicates that the memory allocation failed).\n\n## Mitigation Advice\n\n1. Always check the return value of `malloc` for null. If `malloc` fails to allocate the requested memory, it returns null. Not checking for this can lead to null pointer dereferencing which can crash the program or lead to undefined behavior.\n\n2. Be aware of the size of the memory you are trying to allocate. If the size is user-controlled or can be influenced by an attacker, it can lead to buffer overflows or memory corruption.\n\n3. Consider using functions that limit the amount of memory that can be written such as `calloc` or `strncpy` instead of `malloc` and `strcpy`.\n\n## Source Code Fix Recommendation\n\n```cpp\nHsaSystemProperties* properties = (HsaSystemProperties*) malloc(sizeof(HsaSystemProperties));\nif (properties == NULL) {\n    // Handle error\n    exit(1);\n}\n```\n\nIn this fixed code, we check if `malloc` returned null and handle the error appropriately.\n\n## Library Dependencies\n\nThe `malloc` function is part of the C standard library, so no additional libraries are needed for this code snippet.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-643dfe2a-6bd7-4305-a434-dd7a2eaf228f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a multiplication, as in the provided code snippet, and one of the operands is controlled by an attacker, it can lead to an integer overflow. This overflow can cause the `malloc` function to allocate less memory than expected, leading to a buffer overflow vulnerability when this memory is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and limit the size of the input that is used in the `malloc` function. You should also consider using functions that can handle integer overflows safely, such as `calloc`. \n\n## Source Code Fix Recommendation\n\nReplace the `malloc` function with the `calloc` function, which is designed to handle integer overflows. Here is how you can do it:\n\n```cpp\n// Old vulnerable code\n// uint32_t* ptr = (uint32_t*) malloc(NumberOfNodes * sizeof(uint32_t));\n\n// New fixed code\nuint32_t* ptr = (uint32_t*) calloc(NumberOfNodes, sizeof(uint32_t));\nif (ptr == NULL) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-eebbdcbd-de58-4cd1-b2d4-81de8784a9f6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f36689e7-df0b-486b-b606-a6dc41e33dce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nif (sizeof(tbl->cache[cache_cnt]) >= sizeof(HsaCacheProperties)) {\n    memcpy(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n} else {\n    // Handle the error\n}\n```\n\nIn this fix, we first check if the destination buffer (`tbl->cache[cache_cnt]`) is large enough to hold the data being copied (`HsaCacheProperties`). If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8b3e5e78-c9b0-4577-90dc-5be194f9931c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using `std::string` or `std::strncpy_s` (in C11 and later).\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strncpy_s`:\n\n```cpp\nstrncpy_s((char *)props->AMDName, sizeof(props->AMDName), hsa_gfxip->amd_name, _TRUNCATE);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncpy` or `strncpy_s`\n- `hsa.h` for `props` and `hsa_gfxip` (assuming these are HSA objects)\n\n## References\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1a3f586c-ec92-4b19-b778-adeeba3df248",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. `malloc` is a function that dynamically allocates memory at runtime. If not used properly, it can lead to various vulnerabilities such as buffer overflows, memory leaks, and null pointer dereferencing. In this case, the vulnerability is likely due to not checking the return value of `malloc`. If `malloc` fails to allocate the requested memory, it returns a null pointer. If this null pointer is then used, it can lead to undefined behavior and potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the allocated memory. If `malloc` returns a null pointer, take appropriate action such as freeing any previously allocated resources and terminating the program gracefully.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nHsaEvent* event = (HsaEvent*) malloc(sizeof(HsaEvent));\nif (event == NULL) {\n    // Handle error\n    exit(EXIT_FAILURE);\n}\n```\n\nIn this code, we check if `malloc` returns a null pointer and if so, we handle the error and terminate the program.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function and `exit` function.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP C/C++ Vulnerability Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-73e07da4-8f00-464f-ba04-e03837445b75",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c5c7d9aa-300d-4e21-b8f3-fb090321f12c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-72129fd0-a92c-4607-b361-cb43426d9110",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-32d3ba9b-80d9-4b6f-9bbe-2303552a7397",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function copies a string from one location to another, up to a specified maximum number of characters. If the source string is longer than the specified maximum, the destination buffer can overflow, leading to potential security issues such as code execution, data corruption, and denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that automatically handle buffer sizes and ensure null-termination, such as `strlcpy` or `strncpy_s`. If these are not available, ensure that you manually null-terminate your strings and never copy more characters than can fit in the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with a safer alternative. For example, you could use `strncpy_s` like this:\n\n```cpp\nstrncpy_s(cpuinfo[proc].model_name, sizeof(cpuinfo[proc].model_name), p, HSA_PUBLIC_NAME_SIZE);\n```\n\nThis will ensure that no more than `HSA_PUBLIC_NAME_SIZE` characters are copied, and that the destination string is always null-terminated.\n\n## Library Dependencies\n\nThe code example provided does not appear to have any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure to check the validity of external resources."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-955015ff-a907-4d09-8ad3-499b5bd25ec9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-634c0549-32fa-4727-9308-ed352fafe0fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-14fa99bd-b65d-4e77-a179-5ef1b595122b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow. This function copies a string from one location to another, but it does not automatically append a null character at the end of the copied string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, or even allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, `strncpy(cpuinfo[proc].model_name, p, strlen(p))`, the `strncpy` function is used to copy the string `p` into `cpuinfo[proc].model_name`. If the length of `p` is greater than the size of `cpuinfo[proc].model_name`, this can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string, including the null character. You should also always manually append a null character at the end of the copied string.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strncpy` is `strlcpy`, which automatically appends a null character at the end of the copied string. However, `strlcpy` is not available in all C libraries. If `strlcpy` is not available, you can use `snprintf` instead, which also automatically appends a null character.\n\nHere is how you can fix the provided code snippet:\n\n```cpp\nsnprintf(cpuinfo[proc].model_name, sizeof(cpuinfo[proc].model_name), \"%s\", p);\n```\n\n## Library Dependencies\n\nThe provided code snippet does not specify any library dependencies. However, the `strncpy` function is part of the C standard library, so you need to include `<cstring>` or `<string.h>` to use it. The `snprintf` function is also part of the C standard library, so you need to include `<cstdio>` or `<stdio.h>` to use it.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-25c36bfa-8d6a-4cf6-9049-22207ec50bea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2e667230-0d75-4268-becf-25f671a1e6fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. Here is an example of how to do this:\n\n```cpp\nif (s_attr <= sizeof(args->attrs)) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1d80937e-96f0-4902-84f2-99792e049b01",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(cpuinfo[proc].model_name, p, p_len)`, the `memcpy` function is copying `p_len` bytes from the memory location pointed to by `p` to `cpuinfo[proc].model_name`. If `p_len` is larger than the size of `cpuinfo[proc].model_name`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `strncpy`:\n\n```cpp\nif (sizeof(cpuinfo[proc].model_name) > p_len) {\n    strncpy(cpuinfo[proc].model_name, p, p_len);\n    cpuinfo[proc].model_name[p_len] = '\\0'; // Ensure null termination\n} else {\n    // Handle error: source is too large to fit in destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the original code snippet. The `strncpy` function is also part of the C standard library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-55e33952-5c61-49f4-bd31-d2523058ab2b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using `std::string` or `std::strncpy_s` (in C11 and later).\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `std::strncpy_s`:\n\n```cpp\n#include <string.h>\n\n// ...\n\nif (cpuinfo->model_name != nullptr) {\n    std::strncpy_s((char *)props->AMDName, sizeof(props->AMDName), cpuinfo->model_name, _TRUNCATE);\n} else {\n    props->AMDName[0] = '\\0';\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string.h>`: for `strncpy` and `strncpy_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-b03cc85b-c116-4e27-a8e5-043c4d9808d0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-06dc8282-b70f-4fdf-91c3-a2192439096b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(PAGE_SIZE)` function in C++ is used to allocate a block of memory of size `PAGE_SIZE`. If the allocation is successful, it returns a pointer to the beginning of the block. The vulnerability arises when the `malloc` function fails to allocate the requested memory, which can lead to a NULL pointer being returned. If this NULL pointer is not properly checked before being used, it can lead to a NULL pointer dereference, causing the program to crash or leading to undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc` before using the pointer. If `malloc` returns NULL, this means that the memory allocation failed. In this case, you should handle the error appropriately, for example by freeing any previously allocated resources and terminating the program with an error message.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc` and check its return value:\n\n```cpp\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint main() {\n    void* ptr = malloc(PAGE_SIZE);\n    if (ptr == NULL) {\n        // Handle error\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, if `malloc` fails to allocate the memory, the program prints an error message and exits with a failure status.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdlib.h\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-d3ed6672-364f-47a3-9a97-5795608fa55d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(shared_cpu_map)`, consider using `strnlen(shared_cpu_map, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of `shared_cpu_map`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your code.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a378cb08-9a5f-4df2-bfe6-1a42153c9aec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to be examined.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nconst char* prefix = \"example\";\nsize_t length = strlen(prefix);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nconst char* prefix = \"example\";\nsize_t length = strnlen(prefix, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-398fa38f-1fee-4249-80bf-12315224d671",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-06f9a610-9cf7-4b95-95c1-18b8e6d78c6f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc(sizeof(uint32_t)` is used, which can lead to undefined behavior if not handled correctly. This vulnerability can result in memory leaks, buffer overflows, or other memory-related issues if the allocated memory is not properly managed.\n\n### General Mitigation Advice\n\n1. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n2. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type and that the parentheses are properly closed.\n3. **Free Allocated Memory**: Always free the allocated memory when it is no longer needed to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) for automatic memory management.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdint>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n    // Corrected malloc usage with error checking\n    uint32_t* ptr = static_cast<uint32_t*>(malloc(sizeof(uint32_t)));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdint>`: For fixed-width integer types like `uint32_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n- `<iostream>`: For input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-28fd193c-1a35-4a42-9a1a-3fdb821529b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(*n_entries * *entry_size)` function in C++ is used to dynamically allocate memory. The vulnerability arises when the multiplication of `*n_entries` and `*entry_size` results in an integer overflow. This can lead to a smaller block of memory being allocated than expected, which can subsequently lead to buffer overflow when the program tries to write more data to the allocated memory than it can hold. This can result in data corruption, crashes, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always check for integer overflows when performing arithmetic operations, especially when these operations are used to calculate the size of memory allocation.\n2. Use functions that can handle large numbers safely.\n3. Validate all input data to ensure it is within expected ranges.\n\n## Source Code Fix Recommendation\n\nA simple way to fix this vulnerability is to check for integer overflow before calling `malloc`. Here is an example:\n\n```cpp\nif (*n_entries && *entry_size > SIZE_MAX / *n_entries) {\n    /* Handle error - integer overflow */\n} else {\n    void *ptr = malloc(*n_entries * *entry_size);\n    if (!ptr) {\n        /* Handle error - memory allocation failed */\n    }\n}\n```\n\nIn this code, `SIZE_MAX / *n_entries` is the maximum value that `*entry_size` can have without causing an overflow. If `*entry_size` is larger than this value, an overflow would occur, so we handle it as an error.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-96d7217c-bdf5-41cf-84bd-4f473a73e44c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nsize_t num_queues_size = sizeof(num_queues);\nif (queue_ptr != NULL && num_queues_size <= sizeof(queue_ptr)) {\n    memcpy(queue_ptr, convert_queue_ids(num_queues, Queues), num_queues_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if `queue_ptr` is not NULL and if its size is greater than or equal to the size of `num_queues`. If both conditions are met, we proceed with the `memcpy`. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f76fe6da-487d-4a68-8d06-e70c5cf7f294",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the multiplication `*entry_size * *n_entries` results in an integer overflow, the allocated memory block will be smaller than expected, leading to a buffer overflow vulnerability. This can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and limit the size of the memory you are trying to allocate. Avoid using user-supplied values directly in memory allocation functions. Also, consider using functions that can handle memory allocation errors more gracefully, such as `calloc`, which zeroes out the allocated memory and can help prevent some types of vulnerabilities.\n\n## Source Code Fix Recommendation\n\nInstead of using `malloc(*entry_size * *n_entries)`, consider using a safer alternative like `calloc(*n_entries, *entry_size)`. This function will allocate the memory and initialize it to zero. If the multiplication overflows, `calloc` will return a null pointer, which you can check for.\n\n```cpp\nif ((*n_entries > 0) && (*entry_size > 0)) {\n    void* ptr = calloc(*n_entries, *entry_size);\n    if (ptr == NULL) {\n        // Handle allocation failure\n    } else {\n        // Continue with program\n    }\n} else {\n    // Handle invalid sizes\n}\n```\n\n## Library Dependencies\n\nThe `malloc` and `calloc` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-03146ea4-c0cb-4495-bc66-6cd16ca586f9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory to be allocated is not correctly calculated or checked, leading to insufficient memory allocation or excessive allocation that can be exploited by attackers.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using C++ standard library features like `std::vector` or `std::unique_ptr` which handle memory management more safely.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Boundary Checks**: Implement boundary checks to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t buff_size = 1024; // Example buffer size\n    char* buffer = (char*)malloc(buff_size);\n\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the buffer for some operations\n    // ...\n\n    // Free the allocated memory\n    free(buffer);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ff8ef29d-baf1-401a-a1ae-19546fb0762f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory to be allocated is not correctly calculated or checked, leading to insufficient memory allocation or excessive allocation that can be exploited by attackers.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using C++ standard library features like `std::vector` or `std::unique_ptr` which handle memory management more safely.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Boundary Checks**: Implement boundary checks to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t buff_size = 1024; // Example buffer size\n    char* buffer = (char*)malloc(buff_size);\n\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the buffer for some operations\n    // ...\n\n    // Free the allocated memory\n    free(buffer);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0120dd0c-433d-4a09-88e2-a26f325dfe40",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C is used to dynamically allocate a block of memory and returns a pointer to the first byte of the allocated space. The vulnerability arises when the size of the memory to be allocated is controlled by the user or an attacker, which can lead to various security issues such as buffer overflow, memory corruption, or denial of service.\n\n## Mitigation Advice\n\n1. Always validate and sanitize user input: Never trust user input blindly. Always validate it before using it in your program. This can prevent many security vulnerabilities.\n\n2. Use secure functions: Instead of using `malloc()`, consider using functions like `calloc()`, which not only allocates memory but also initializes it to zero. This can prevent information leakage.\n\n3. Error handling: Always check the return value of `malloc()`. If it returns NULL, it means that the memory allocation failed. Ignoring this can lead to null pointer dereferencing, which can crash your program.\n\n## Source Code Fix Recommendation\n\n```c++\n// Check if the size is not too large\nif (args.enable.rinfo_size > MAX_SIZE) {\n    fprintf(stderr, \"Size is too large\\n\");\n    exit(1);\n}\n\n// Allocate memory\nvoid* ptr = malloc(args.enable.rinfo_size);\n\n// Check if the memory allocation was successful\nif (ptr == NULL) {\n    fprintf(stderr, \"Memory allocation failed\\n\");\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library (`stdlib.h`), so no additional libraries are needed.\n\n## References\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a06eb0de-4a05-4fc7-9780-b97e4efbfd54",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a multiplication, like in the provided code snippet, and one of the operands is controlled by a user, an integer overflow can occur. This can lead to a smaller block of memory being allocated than expected, which in turn can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check the result of the multiplication for an overflow before passing it to `malloc`. This can be done by comparing the result of the multiplication with the maximum value that can be stored in the type of the result. If the result is larger, an overflow has occurred and the function should not proceed.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <climits>\n#include <cstdlib>\n\n// ...\n\nsize_t numNodes = ...; // get the number of nodes\nif (numNodes > (SIZE_MAX / sizeof(bool))) {\n    // handle error, e.g., by returning or throwing an exception\n}\nbool* nodes = static_cast<bool*>(malloc(numNodes * sizeof(bool)));\nif (nodes == nullptr) {\n    // handle error, e.g., by returning or throwing an exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `climits`: for `SIZE_MAX`\n- `cstdlib`: for `malloc`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-93e06f98-86fd-405c-ab64-af68d6f28e1e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a multiplication, as in the provided code snippet, and one of the operands is controlled by an attacker, it can lead to an integer overflow. This overflow can cause the `malloc` function to allocate less memory than expected, leading to a buffer overflow vulnerability when this memory is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and limit the size of the input that is used in the `malloc` function. You should also consider using functions that can handle integer overflows safely, such as `calloc`. \n\n## Source Code Fix Recommendation\n\nReplace the `malloc` function with the `calloc` function, which takes two arguments: the number of elements and the size of each element. This function will return a pointer to the allocated memory or NULL if the memory could not be allocated. The `calloc` function also initializes the allocated memory to zero.\n\n```cpp\nuint32_t *queues = (uint32_t *)calloc(NumQueues, sizeof(uint32_t));\nif (queues == NULL) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `malloc` function and the `cstdint` library for the `uint32_t` type.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1a0150a9-ea0e-48af-848b-0898b34ef3bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a multiplication, as in the case of `NumNodes * sizeof(struct process_doorbells)`, and the multiplication results in an integer overflow, the allocated memory block will be smaller than expected. This can lead to buffer overflow vulnerabilities, where data can be written past the end of the allocated block, potentially leading to code execution, denial of service, or information disclosure vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always check for integer overflows when calculating the size argument for `malloc`.\n2. Consider using functions that automatically handle these checks, such as `calloc`.\n3. Validate and limit the size of the input to prevent excessive memory allocation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (NumNodes > SIZE_MAX / sizeof(struct process_doorbells)) {\n    // handle error\n} else {\n    struct process_doorbells* ptr = (struct process_doorbells*) malloc(NumNodes * sizeof(struct process_doorbells));\n    if (!ptr) {\n        // handle error\n    } else {\n        // use ptr\n    }\n}\n```\n\nIn this code, we first check if the multiplication would result in an integer overflow. If it would, we handle the error. If not, we proceed with the `malloc`.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies beyond the standard C++ libraries.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0596897d-4df2-41e9-ae1c-39c4762b2348",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `s_attr` (the size of the data to be copied) is larger than the size of `attrs` (the destination buffer), it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(args->attrs);\nif (size <= sizeof(attrs)) {\n    memcpy(attrs, args->attrs, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data to be copied and check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1801eb6a-bd65-4aaf-9305-233f0de6c705",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow or cause a system crash (Denial of Service attacks).\n\nIn the provided code snippet, `memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)`, if `CUMaskCount / 8` is larger than the size of `q->cu_mask`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before performing the copy operation. \n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which works well with C++ containers that know their size.\n\n```cpp\n#include <algorithm>\n\n// Assuming q->cu_mask and QueueCUMask are std::vector<char>\nstd::copy(QueueCUMask.begin(), QueueCUMask.begin() + CUMaskCount / 8, q->cu_mask.begin());\n```\n\nIf you are dealing with raw pointers, consider using `std::copy_n`:\n\n```cpp\n#include <algorithm>\n\n// Assuming q->cu_mask and QueueCUMask are char*\nstd::copy_n(QueueCUMask, CUMaskCount / 8, q->cu_mask);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3d3ede06-030b-48ab-a367-6c24459ebb58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. Here is an example of how to do this:\n\n```cpp\nif (s_attr <= sizeof(args->attrs)) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cd674a8d-0819-4a81-930d-03665f527d58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. Here is an example of how to do this:\n\n```cpp\nif (s_attr <= sizeof(args->attrs)) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f55fd03d-c24e-438a-ab07-9c640836dfee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. In this case, the vulnerability lies in the fact that the size of the memory to be allocated is determined by the `mapped_device_id_array_size` member of the `vm_obj` object. If this value is controlled by an attacker, it can lead to a buffer overflow or underflow, which can in turn lead to arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize input that is used to determine the size of memory to be allocated. You should also consider using functions that limit the amount of memory that can be written, such as `calloc`, which initializes the allocated memory to zero.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (vm_obj->mapped_device_id_array_size > MAX_SIZE) {\n    // Handle error\n} else {\n    vm_obj->mapped_device_id_array = (int*) malloc(vm_obj->mapped_device_id_array_size);\n    if (vm_obj->mapped_device_id_array == NULL) {\n        // Handle error\n    }\n}\n```\n\nIn this code, `MAX_SIZE` is a predefined constant that represents the maximum allowable size. If the size exceeds this value, an error is handled. If the size is within the allowable range, memory is allocated. If the allocation fails, another error is handled.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6139a7c6-4700-4061-8ce0-9ce1770a15b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C is used to dynamically allocate a block of memory. If the size of the memory to be allocated is controlled by the user or an external input, it can lead to several vulnerabilities such as Buffer Overflow, Integer Overflow, or even Denial of Service (DoS) if the size is extremely large. In this case, the size of the memory to be allocated is determined by `vm_obj->registered_device_id_array_size`, which could potentially be manipulated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate and sanitize the input that determines the size of the memory to be allocated.\n2. Use functions that limit the size of the memory to be allocated, such as `calloc()`.\n3. Handle the case where `malloc()` fails and returns a NULL pointer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```c++\nif (vm_obj->registered_device_id_array_size > MAX_SIZE) {\n    // Handle error\n} else {\n    vm_obj->registered_device_id_array_size = (device_id*) malloc(vm_obj->registered_device_id_array_size * sizeof(device_id));\n    if (vm_obj->registered_device_id_array_size == NULL) {\n        // Handle error\n    }\n}\n```\n\nIn this code, `MAX_SIZE` is a predefined constant that limits the size of the memory to be allocated. The `sizeof(device_id)` is used to ensure that the correct amount of memory is allocated for the array.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc()` function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9c1d7050-0717-4350-a1e2-03dbe432ffb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(importArgs.share_handle) >= sizeof(SharedMemoryStruct->ShareHandle)) {\n    memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source data. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f7764446-9fa4-4d82-9ad4-b9ee6773bd83",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`. \n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include size checks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t size = sizeof(SharedMemoryStruct->ShareHandle);\nif (size <= sizeof(exportArgs.share_handle)) {\n    memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-04929bae-232e-40b3-9391-e7180d4db23c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the C function `memcpy()`. This function is used to copy a block of memory from one location to another. If the destination buffer size is smaller than the source buffer size, it can lead to a buffer overflow. This can overwrite data in memory and can lead to unpredictable program behavior, crashes, or even code execution.\n\nIn the provided code snippet, the vulnerability arises if `ids_array_size` is greater than the remaining space in `obj->mapped_device_id_array`. This can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy()`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (obj->mapped_device_id_array_size/sizeof(uint32_t) + ids_array_size <= sizeof(obj->mapped_device_id_array)) {\n    memcpy(&obj->mapped_device_id_array\n        [obj->mapped_device_id_array_size/sizeof(uint32_t)],\n        ids_array, ids_array_size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fix, we first check if the destination buffer has enough space to hold the data being copied. If it does, we proceed with the `memcpy()`. If it does not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the declaration of the `memcpy()` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b82bb749-8e6f-496f-95a3-85910a1f9da4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc(sizeof(uint32_t)` is used, which can lead to undefined behavior if not handled correctly. This vulnerability can result in memory leaks, buffer overflows, or other memory-related issues if the allocated memory is not properly managed.\n\n### General Mitigation Advice\n\n1. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n2. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type and that the parentheses are properly closed.\n3. **Free Allocated Memory**: Always free the allocated memory when it is no longer needed to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) for automatic memory management.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdint>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n    // Corrected malloc usage with error checking\n    uint32_t* ptr = static_cast<uint32_t*>(malloc(sizeof(uint32_t)));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdint>`: For fixed-width integer types like `uint32_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n- `<iostream>`: For input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-dee1ec66-78ea-4f44-8b74-fe47e49a6ec1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nsize_t size = sizeof(*process_apertures);\nif (size <= sizeof(args_old.process_apertures)) {\n    memcpy(process_apertures, args_old.process_apertures, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is less than or equal to the size of the source buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-96c0df3c-d80e-4907-a9bc-a443a127761a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used correctly. The specific vulnerability in this case is that the size of the memory to be allocated might be controlled by the user or it might not be checked for errors after allocation. This can lead to various issues such as buffer overflow, memory leak, or even denial of service if an attacker can cause the program to allocate large amounts of memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate the size of the memory to be allocated and check the return value of `malloc` for errors. If `malloc` fails, it returns a null pointer, and any attempt to use this null pointer will lead to undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the code:\n\n```cpp\nvm_object_t *object = (vm_object_t *) malloc(sizeof(vm_object_t));\nif (object == NULL) {\n    // handle error, for example by returning or throwing an exception\n    return;\n}\n// continue with your code\n```\n\nIn this code, we check if `malloc` returns a null pointer and handle the error appropriately.\n\n## Library Dependencies\n\nThe `malloc` function is part of the C standard library, so no additional libraries are needed for this code.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4070776e-33d0-4a8b-a4ea-485d4a49f744",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used correctly. The specific vulnerability in this case is that the size of the memory to be allocated might be miscalculated or manipulated, leading to buffer overflow, underflow, or other memory corruption issues. This can lead to unpredictable program behavior, crashes, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate the size of the memory to be allocated and ensure it is within the expected range. Also, always check the return value of `malloc` to ensure that the memory allocation was successful. If `malloc` fails, it returns a null pointer, and any attempt to use this pointer will lead to undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the code:\n\n```cpp\n#include <stdlib.h>\n\nvm_area_t *ptr = (vm_area_t*) malloc(sizeof(vm_area_t));\nif (ptr == NULL) {\n    // handle error\n} else {\n    // use ptr\n    free(ptr);\n}\n```\n\nIn this code, we first allocate memory using `malloc` and then check if the returned pointer is null. If it is null, we handle the error (for example, by logging an error message and terminating the program). If it is not null, we use the pointer and then free the memory when we are done.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` and `free` functions.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-caf5f647-da66-45be-a0b9-8e64e67c2455",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C is used to dynamically allocate memory at runtime. However, it can lead to vulnerabilities if not used properly. If the size argument passed to `malloc` is controlled by an attacker, it can lead to a buffer overflow or underflow, which can further lead to arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\n1. Always validate and sanitize input that is used to determine the size of memory allocation.\n2. Check the return value of `malloc`. If it returns `NULL`, it means that the memory allocation failed. Failing to check this can lead to null pointer dereferencing.\n3. Always initialize the allocated memory. Uninitialized memory can contain sensitive information.\n4. Free the allocated memory after use to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\n```c\n#include <stdlib.h>\n\n// Assuming counter_props_size is an integer\nif (counter_props_size <= 0) {\n    // Handle error\n}\n\nvoid* ptr = malloc(counter_props_size);\nif (ptr == NULL) {\n    // Handle error\n}\n\n// Initialize memory\nmemset(ptr, 0, counter_props_size);\n\n// Use the allocated memory\n\n// Free the allocated memory\nfree(ptr);\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function and the `string.h` library for the `memset` function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-d34082d9-b7e9-4f6f-a434-56facc4a65e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 1,
                  "endLine": 2394,
                  "endColumn": 46,
                  "charOffset": 70810,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                    "rendered": {
                      "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                      "markdown": "`memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70810,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(IoLinkProperties, <size of IoLinkProperties>,  g_props[NodeId].link, \n\t       NumIoLinks * sizeof(*IoLinkProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-543a5ff8-6702-4bb8-9902-15cf1e7cc72a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2095,
                  "startColumn": 13,
                  "endLine": 2095,
                  "endColumn": 47,
                  "charOffset": 63098,
                  "charLength": 34,
                  "snippet": {
                    "text": "malloc(sizeof(HsaSystemProperties)",
                    "rendered": {
                      "text": "malloc(sizeof(HsaSystemProperties)",
                      "markdown": "`malloc(sizeof(HsaSystemProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63098,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-643dfe2a-6bd7-4305-a434-dd7a2eaf228f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2495,
                  "startColumn": 17,
                  "endLine": 2495,
                  "endColumn": 56,
                  "charOffset": 73106,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc(NumberOfNodes * sizeof(uint32_t)",
                    "rendered": {
                      "text": "malloc(NumberOfNodes * sizeof(uint32_t)",
                      "markdown": "`malloc(NumberOfNodes * sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73106,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eebbdcbd-de58-4cd1-b2d4-81de8784a9f6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 12,
                  "endLine": 1536,
                  "endColumn": 29,
                  "charOffset": 45927,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45927,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f36689e7-df0b-486b-b606-a6dc41e33dce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1499,
                  "startColumn": 3,
                  "endLine": 1501,
                  "endColumn": 36,
                  "charOffset": 45055,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                    "rendered": {
                      "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                      "markdown": "`memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45055,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tbl->cache[cache_cnt++], <size of &tbl->cache[cache_cnt++]>, \n\t\t\t       this_cache, \n\t\t\t       sizeof(HsaCacheProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8b3e5e78-c9b0-4577-90dc-5be194f9931c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1242,
                  "startColumn": 3,
                  "endLine": 1243,
                  "endColumn": 27,
                  "charOffset": 37103,
                  "charLength": 80,
                  "snippet": {
                    "text": "strncpy((char *)props->AMDName, hsa_gfxip->amd_name,\n\t\t\t\t\tsizeof(props->AMDName)",
                    "rendered": {
                      "text": "strncpy((char *)props->AMDName, hsa_gfxip->amd_name,\n\t\t\t\t\tsizeof(props->AMDName)",
                      "markdown": "`strncpy((char *)props->AMDName, hsa_gfxip->amd_name,\n\t\t\t\t\tsizeof(props->AMDName)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37103,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)props->AMDName, \n\t\t\t\t\tsizeof(props->AMDName,  hsa_gfxip->amd_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37103,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)props->AMDName,  hsa_gfxip->amd_name, \n\t\t\t\t\tsizeof(props->AMDName)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a3f586c-ec92-4b19-b778-adeeba3df248",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 15,
                  "endLine": 61,
                  "endColumn": 38,
                  "charOffset": 1979,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(sizeof(HsaEvent)",
                    "rendered": {
                      "text": "malloc(sizeof(HsaEvent)",
                      "markdown": "`malloc(sizeof(HsaEvent)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1979,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-73e07da4-8f00-464f-ba04-e03837445b75",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1089,
                  "startColumn": 12,
                  "endLine": 1089,
                  "endColumn": 29,
                  "charOffset": 30952,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30952,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c5c7d9aa-300d-4e21-b8f3-fb090321f12c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1637,
                  "startColumn": 12,
                  "endLine": 1637,
                  "endColumn": 29,
                  "charOffset": 49078,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49078,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72129fd0-a92c-4607-b361-cb43426d9110",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 985,
                  "startColumn": 11,
                  "endLine": 985,
                  "endColumn": 20,
                  "charOffset": 28443,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-32d3ba9b-80d9-4b6f-9bbe-2303552a7397",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Prohibited strncpy Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 946,
                  "startColumn": 4,
                  "endLine": 946,
                  "endColumn": 62,
                  "charOffset": 27323,
                  "charLength": 58,
                  "snippet": {
                    "text": "strncpy(cpuinfo[proc].model_name, p, HSA_PUBLIC_NAME_SIZE)",
                    "rendered": {
                      "text": "strncpy(cpuinfo[proc].model_name, p, HSA_PUBLIC_NAME_SIZE)",
                      "markdown": "`strncpy(cpuinfo[proc].model_name, p, HSA_PUBLIC_NAME_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27323,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "strcpy_s(cpuinfo[proc].model_name,  HSA_PUBLIC_NAME_SIZE,  p)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27323,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "strlcpy(cpuinfo[proc].model_name,  p,  HSA_PUBLIC_NAME_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-955015ff-a907-4d09-8ad3-499b5bd25ec9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 29,
                  "endLine": 944,
                  "endColumn": 38,
                  "charOffset": 27286,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-634c0549-32fa-4727-9308-ed352fafe0fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 943,
                  "startColumn": 41,
                  "endLine": 943,
                  "endColumn": 50,
                  "charOffset": 27241,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14fa99bd-b65d-4e77-a179-5ef1b595122b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 943,
                  "startColumn": 4,
                  "endLine": 943,
                  "endColumn": 50,
                  "charOffset": 27204,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncpy(cpuinfo[proc].model_name, p, strlen(p)",
                    "rendered": {
                      "text": "strncpy(cpuinfo[proc].model_name, p, strlen(p)",
                      "markdown": "`strncpy(cpuinfo[proc].model_name, p, strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27204,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcpy_s(cpuinfo[proc].model_name,  strlen(p,  p)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27204,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcpy(cpuinfo[proc].model_name,  p,  strlen(p)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25c36bfa-8d6a-4cf6-9049-22207ec50bea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1301,
                  "startColumn": 12,
                  "endLine": 1301,
                  "endColumn": 29,
                  "charOffset": 38826,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38826,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2e667230-0d75-4268-becf-25f671a1e6fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 1,
                  "endLine": 252,
                  "endColumn": 35,
                  "charOffset": 6680,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6680,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1d80937e-96f0-4902-84f2-99792e049b01",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 988,
                  "startColumn": 3,
                  "endLine": 988,
                  "endColumn": 45,
                  "charOffset": 28528,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                    "rendered": {
                      "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                      "markdown": "`memcpy(cpuinfo[proc].model_name, p, p_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28528,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cpuinfo[proc].model_name, <size of cpuinfo[proc].model_name>,  p,  p_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-55e33952-5c61-49f4-bd31-d2523058ab2b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 852,
                  "startColumn": 4,
                  "endLine": 852,
                  "endColumn": 80,
                  "charOffset": 24683,
                  "charLength": 76,
                  "snippet": {
                    "text": "strncpy((char *)props->AMDName, cpuinfo->model_name, sizeof(props->AMDName))",
                    "rendered": {
                      "text": "strncpy((char *)props->AMDName, cpuinfo->model_name, sizeof(props->AMDName))",
                      "markdown": "`strncpy((char *)props->AMDName, cpuinfo->model_name, sizeof(props->AMDName))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24683,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)props->AMDName,  sizeof(props->AMDName,  cpuinfo->model_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24683,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)props->AMDName,  cpuinfo->model_name,  sizeof(props->AMDName)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b03cc85b-c116-4e27-a8e5-043c4d9808d0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 660,
                  "startColumn": 12,
                  "endLine": 660,
                  "endColumn": 29,
                  "charOffset": 19748,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19748,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-06dc8282-b70f-4fdf-91c3-a2192439096b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 727,
                  "startColumn": 12,
                  "endLine": 727,
                  "endColumn": 29,
                  "charOffset": 21311,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(PAGE_SIZE)",
                    "rendered": {
                      "text": "malloc(PAGE_SIZE)",
                      "markdown": "`malloc(PAGE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21311,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d3ed6672-364f-47a3-9a97-5795608fa55d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 13,
                  "endLine": 467,
                  "endColumn": 35,
                  "charOffset": 13980,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(shared_cpu_map)",
                    "rendered": {
                      "text": "strlen(shared_cpu_map)",
                      "markdown": "`strlen(shared_cpu_map)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a378cb08-9a5f-4df2-bfe6-1a42153c9aec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 18,
                  "endLine": 344,
                  "endColumn": 32,
                  "charOffset": 11181,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(prefix)",
                    "rendered": {
                      "text": "strlen(prefix)",
                      "markdown": "`strlen(prefix)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-398fa38f-1fee-4249-80bf-12315224d671",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 7,
                  "endLine": 941,
                  "endColumn": 16,
                  "charOffset": 27131,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-06f9a610-9cf7-4b95-95c1-18b8e6d78c6f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 497,
                  "startColumn": 26,
                  "endLine": 497,
                  "endColumn": 49,
                  "charOffset": 13479,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(sizeof(uint32_t)",
                    "rendered": {
                      "text": "malloc(sizeof(uint32_t)",
                      "markdown": "`malloc(sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13479,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28fd193c-1a35-4a42-9a1a-3fdb821529b8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 493,
                  "startColumn": 9,
                  "endLine": 493,
                  "endColumn": 41,
                  "charOffset": 13337,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc(*n_entries * *entry_size)",
                    "rendered": {
                      "text": "malloc(*n_entries * *entry_size)",
                      "markdown": "`malloc(*n_entries * *entry_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13337,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-96d7217c-bdf5-41cf-84bd-4f473a73e44c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 2,
                  "endLine": 532,
                  "endColumn": 57,
                  "charOffset": 14449,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                    "rendered": {
                      "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                      "markdown": "`memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14449,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(queue_ptr, <size of queue_ptr>,  convert_queue_ids(num_queues,  Queues)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f76fe6da-487d-4a68-8d06-e70c5cf7f294",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 9,
                  "endLine": 470,
                  "endColumn": 41,
                  "charOffset": 12747,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc(*entry_size * *n_entries)",
                    "rendered": {
                      "text": "malloc(*entry_size * *n_entries)",
                      "markdown": "`malloc(*entry_size * *n_entries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12747,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-03146ea4-c0cb-4495-bc66-6cd16ca586f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 52,
                  "endLine": 218,
                  "endColumn": 69,
                  "charOffset": 5890,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(buff_size)",
                    "rendered": {
                      "text": "malloc(buff_size)",
                      "markdown": "`malloc(buff_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5890,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ff8ef29d-baf1-401a-a1ae-19546fb0762f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 139,
                  "startColumn": 50,
                  "endLine": 139,
                  "endColumn": 67,
                  "charOffset": 3647,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(buff_size)",
                    "rendered": {
                      "text": "malloc(buff_size)",
                      "markdown": "`malloc(buff_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3647,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0120dd0c-433d-4a09-88e2-a26f325dfe40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 430,
                  "startColumn": 17,
                  "endLine": 430,
                  "endColumn": 47,
                  "charOffset": 11709,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc(args.enable.rinfo_size)",
                    "rendered": {
                      "text": "malloc(args.enable.rinfo_size)",
                      "markdown": "`malloc(args.enable.rinfo_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11709,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a06eb0de-4a05-4fc7-9780-b97e4efbfd54",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 22,
                  "endLine": 40,
                  "endColumn": 52,
                  "charOffset": 1501,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc(NumNodes * sizeof(bool)",
                    "rendered": {
                      "text": "malloc(NumNodes * sizeof(bool)",
                      "markdown": "`malloc(NumNodes * sizeof(bool)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1501,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-93e06f98-86fd-405c-ab64-af68d6f28e1e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 885,
                  "startColumn": 17,
                  "endLine": 885,
                  "endColumn": 52,
                  "charOffset": 23937,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(NumQueues * sizeof(uint32_t)",
                    "rendered": {
                      "text": "malloc(NumQueues * sizeof(uint32_t)",
                      "markdown": "`malloc(NumQueues * sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23937,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a0150a9-ea0e-48af-848b-0898b34ef3bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 13,
                  "endLine": 113,
                  "endColumn": 63,
                  "charOffset": 3408,
                  "charLength": 50,
                  "snippet": {
                    "text": "malloc(NumNodes * sizeof(struct process_doorbells)",
                    "rendered": {
                      "text": "malloc(NumNodes * sizeof(struct process_doorbells)",
                      "markdown": "`malloc(NumNodes * sizeof(struct process_doorbells)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3408,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0596897d-4df2-41e9-ae1c-39c4762b2348",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 35,
                  "charOffset": 5079,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(attrs, args->attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(attrs, args->attrs, s_attr)",
                      "markdown": "`memcpy(attrs, args->attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5079,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(attrs, <size of attrs>,  args->attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1801eb6a-bd65-4aaf-9305-233f0de6c705",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 810,
                  "startColumn": 1,
                  "endLine": 810,
                  "endColumn": 49,
                  "charOffset": 21859,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                    "rendered": {
                      "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                      "markdown": "`memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21859,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(q->cu_mask, <size of q->cu_mask>,  QueueCUMask,  CUMaskCount / 8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d3ede06-030b-48ab-a367-6c24459ebb58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 35,
                  "charOffset": 4275,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4275,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cd674a8d-0819-4a81-930d-03665f527d58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 1,
                  "endLine": 67,
                  "endColumn": 35,
                  "charOffset": 2209,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2209,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f55fd03d-c24e-438a-ab07-9c640836dfee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 4117,
                  "startColumn": 15,
                  "endLine": 4117,
                  "endColumn": 58,
                  "charOffset": 120921,
                  "charLength": 43,
                  "snippet": {
                    "text": "malloc(vm_obj->mapped_device_id_array_size)",
                    "rendered": {
                      "text": "malloc(vm_obj->mapped_device_id_array_size)",
                      "markdown": "`malloc(vm_obj->mapped_device_id_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 120921,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6139a7c6-4700-4061-8ce0-9ce1770a15b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 4102,
                  "startColumn": 15,
                  "endLine": 4102,
                  "endColumn": 62,
                  "charOffset": 120266,
                  "charLength": 47,
                  "snippet": {
                    "text": "malloc(vm_obj->registered_device_id_array_size)",
                    "rendered": {
                      "text": "malloc(vm_obj->registered_device_id_array_size)",
                      "markdown": "`malloc(vm_obj->registered_device_id_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 120266,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c1d7050-0717-4350-a1e2-03dbe432ffb4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3817,
                  "startColumn": 1,
                  "endLine": 3818,
                  "endColumn": 34,
                  "charOffset": 111548,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                    "rendered": {
                      "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                      "markdown": "`memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111548,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(importArgs.share_handle, <size of importArgs.share_handle>,  SharedMemoryStruct->ShareHandle, \n\t\t\tsizeof(importArgs.share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f7764446-9fa4-4d82-9ad4-b9ee6773bd83",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3787,
                  "startColumn": 1,
                  "endLine": 3788,
                  "endColumn": 42,
                  "charOffset": 110495,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                    "rendered": {
                      "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                      "markdown": "`memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 110495,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(SharedMemoryStruct->ShareHandle, <size of SharedMemoryStruct->ShareHandle>,  exportArgs.share_handle, \n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-04929bae-232e-40b3-9391-e7180d4db23c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2962,
                  "startColumn": 1,
                  "endLine": 2964,
                  "endColumn": 29,
                  "charOffset": 85760,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                    "rendered": {
                      "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                      "markdown": "`memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85760,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)], <size of &obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)]>, \n\t\t\tids_array,  ids_array_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b82bb749-8e6f-496f-95a3-85910a1f9da4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2645,
                  "startColumn": 21,
                  "endLine": 2645,
                  "endColumn": 44,
                  "charOffset": 76273,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(sizeof(uint32_t)",
                    "rendered": {
                      "text": "malloc(sizeof(uint32_t)",
                      "markdown": "`malloc(sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76273,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dee1ec66-78ea-4f44-8b74-fe47e49a6ec1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2042,
                  "startColumn": 1,
                  "endLine": 2043,
                  "endColumn": 34,
                  "charOffset": 56906,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                    "rendered": {
                      "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                      "markdown": "`memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56906,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(process_apertures, <size of process_apertures>,  args_old.process_apertures, \n\t       sizeof(*process_apertures)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-96c0df3c-d80e-4907-a9bc-a443a127761a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 39,
                  "endLine": 335,
                  "endColumn": 65,
                  "charOffset": 10010,
                  "charLength": 26,
                  "snippet": {
                    "text": "malloc(sizeof(vm_object_t)",
                    "rendered": {
                      "text": "malloc(sizeof(vm_object_t)",
                      "markdown": "`malloc(sizeof(vm_object_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10010,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4070776e-33d0-4a8b-a4ea-485d4a49f744",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 33,
                  "endLine": 321,
                  "endColumn": 57,
                  "charOffset": 9709,
                  "charLength": 24,
                  "snippet": {
                    "text": "malloc(sizeof(vm_area_t)",
                    "rendered": {
                      "text": "malloc(sizeof(vm_area_t)",
                      "markdown": "`malloc(sizeof(vm_area_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9709,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-caf5f647-da66-45be-a0b9-8e64e67c2455",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/perfctr.c"
                },
                "region": {
                  "startLine": 298,
                  "startColumn": 25,
                  "endLine": 298,
                  "endColumn": 51,
                  "charOffset": 7374,
                  "charLength": 26,
                  "snippet": {
                    "text": "malloc(counter_props_size)",
                    "rendered": {
                      "text": "malloc(counter_props_size)",
                      "markdown": "`malloc(counter_props_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/perfctr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7374,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}