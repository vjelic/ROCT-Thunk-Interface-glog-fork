{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "26278970-c011-3c6c-aecc-cf13aa48a718",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source buffers may overlap, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which could lead to null pointer dereference. The absence of explicit bounds or capacity checks further increases the risk. The verdict is supported by the high-confidence classification and the explicit 'GENUINE' verdict from the analysis.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination buffers do not overlap. Add explicit checks to verify that the memory regions are distinct and that neither pointer is null. For example:\n\n```c\nif (args->attrs != NULL && attrs != NULL &&\n    ((args->attrs + s_attr <= attrs) || (attrs + s_attr <= args->attrs))) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: overlapping regions or null pointers\n}\n```\nThis approach prevents undefined behavior by ensuring the memory regions do not overlap and both pointers are valid.\n\n## In Context Remediation 2\nIf overlapping memory regions are possible or cannot be ruled out, use `memmove` instead of `memcpy`, as `memmove` safely handles overlapping regions:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: null pointers\n}\n```\nThis change ensures correct behavior even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "40bcd266-2384-3785-9486-008baf1aa5fa",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. No explicit buffer size or bounds checks are present, and the count argument is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a real issue that requires remediation.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add explicit checks to verify that the memory ranges are distinct and that neither pointer is null. For example:\n\n```c\nif (args->attrs != NULL && attrs != NULL &&\n    ((args->attrs + s_attr <= attrs) || (attrs + s_attr <= args->attrs))) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: overlapping regions or null pointers\n}\n```\nThis approach prevents undefined behavior by ensuring the memory regions do not overlap and both pointers are valid.\n\n## In Context Remediation 2\nIf overlapping memory regions are possible or cannot be ruled out, use `memmove` instead of `memcpy`, as `memmove` safely handles overlapping regions:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: null pointers\n}\n```\nThis change ensures correct behavior even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f35ef05-841d-36ee-9390-16e19706cec2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not have the same risks as `alloca()`. However, remember to manually free the memory allocated by these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to replace `alloca()` with `malloc()`:\n\n```cpp\n// Old code\n// alloca(sizeof(*args) + s_attr)\n\n// New code\nvoid* args = malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // Handle error\n}\n// Use args\n// ...\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a6eed958-abde-35f1-a910-0850a3663f57",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not have the same risks as `alloca()`. However, remember to manually free the memory allocated by these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to replace `alloca()` with `malloc()`:\n\n```cpp\n// Old code\n// alloca(sizeof(*args) + s_attr)\n\n// New code\nvoid* args = malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // Handle error\n}\n// Use args\n// ...\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis indicates that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms this as a genuine issue. The source and destination are both non-null, so null pointer dereference is not a concern here. The main risk is the undefined behavior from overlapping memory regions.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory regions that may overlap, add a runtime check to ensure the source and destination do not overlap before calling memcpy. If overlap is possible, use memmove instead, which is safe for overlapping regions.\n\n```c\nif ((attrs + s_attr <= args->attrs) || (args->attrs + s_attr <= attrs)) {\n    memcpy(attrs, args->attrs, s_attr);\n} else {\n    memmove(attrs, args->attrs, s_attr);\n}\n```\nThis approach ensures that memcpy is only used when it is safe, and memmove is used when overlap is detected.\n\n## In Context Remediation 2\nAlternatively, replace the memcpy call with memmove, which is designed to handle overlapping memory regions safely:\n\n```c\nmemmove(attrs, args->attrs, s_attr);\n```\nThis change eliminates the risk of undefined behavior due to overlapping memory regions.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "eab60fa1-363d-3f93-892e-e0dcfd1cc67c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not have the same risks as `alloca()`. However, remember to manually free the memory allocated by these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to replace `alloca()` with `malloc()`:\n\n```cpp\n// Old code\n// alloca(sizeof(*args) + s_attr)\n\n// New code\nvoid* args = malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // Handle error\n}\n// Use args\n// ...\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "867a2739-0b84-34c7-a9b3-fad7bee50348",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one memory location to another using a standard memory copy function, but there is evidence that the source and destination may refer to overlapping memory regions, which can cause unpredictable results. Additionally, there are no checks to ensure that the source and destination pointers are not null, increasing the risk of a crash or further undefined behavior. The absence of explicit bounds checks or null pointer guards further increases the severity of this issue.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add explicit checks to verify that the memory ranges are distinct and that neither pointer is null. For example:\n\n```c\nif (importArgs.share_handle != NULL && SharedMemoryStruct->ShareHandle != NULL &&\n    ((importArgs.share_handle + sizeof(importArgs.share_handle) <= (void*)SharedMemoryStruct->ShareHandle) ||\n     ((void*)SharedMemoryStruct->ShareHandle + sizeof(importArgs.share_handle) <= importArgs.share_handle))) {\n    memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n} else {\n    // Handle error: overlapping regions or null pointers\n}\n```\nThis approach prevents undefined behavior by ensuring the memory regions do not overlap and are valid.\n\n## In Context Remediation 2\nIf it is possible that the source and destination memory regions may overlap, use a memory move function that is safe for overlapping regions. For example:\n\n```c\nif (importArgs.share_handle != NULL && SharedMemoryStruct->ShareHandle != NULL) {\n    memmove(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n} else {\n    // Handle error: null pointers\n}\n```\nThis ensures correct behavior even if the memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "875b8707-13df-33f0-9548-f0b927d5ba5f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. No evidence of bounds checking or explicit null-termination is present, and the copy length is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a real issue.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add explicit checks to verify that the memory ranges are distinct and that neither pointer is null. For example:\n\n```c\nif (args->attrs != NULL && attrs != NULL &&\n    ((args->attrs + s_attr <= attrs) || (attrs + s_attr <= args->attrs))) {\n    memcpy(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: overlapping regions or null pointers\n}\n```\nThis approach prevents undefined behavior by ensuring the memory regions are safe for memcpy.\n\n## In Context Remediation 2\nIf it is possible that the source and destination memory regions may overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n} else {\n    // Handle error: null pointers\n}\n```\nThis change ensures correct behavior even if the memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source and destination do not overlap, and the source pointer may be null at this point in the code, which further increases the risk. The verdict is marked as genuine, and the classification specifically highlights undefined behavior due to possible memory overlap. These factors indicate a real risk of memory corruption or program crashes if the overlap occurs.\n\n## In Context Remediation 1\nBefore performing the memory copy, add a check to ensure that the source and destination memory regions do not overlap. If overlap is possible, use a safe copying method or handle the case appropriately. For example:\n\n```c\nif ((ids_array + ids_array_size <= (void *)&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)]) ||\n    ((void *)&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)] + ids_array_size <= ids_array)) {\n    memcpy(&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)], ids_array, ids_array_size);\n} else {\n    // Handle overlap safely, e.g., use memmove or copy to a temporary buffer\n}\n```\nThis ensures that the memory regions do not overlap before calling `memcpy`.\n\n## In Context Remediation 2\nIf overlap between the source and destination cannot be ruled out, replace `memcpy` with `memmove`, which is designed to handle overlapping memory regions safely:\n\n```c\nmemmove(&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)], ids_array, ids_array_size);\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which further increases the risk of runtime errors. The absence of explicit bounds checks or guards, and the lack of evidence that the length argument is derived from the actual capacity of the destination, reinforce the assessment that this is a real and actionable issue.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add explicit checks to verify that the memory ranges are distinct. Also, check that both pointers are non-null before calling memcpy.\n\n```c\nif (SharedMemoryStruct->ShareHandle != NULL && exportArgs.share_handle != NULL &&\n    ((uintptr_t)SharedMemoryStruct->ShareHandle + sizeof(SharedMemoryStruct->ShareHandle) <= (uintptr_t)exportArgs.share_handle ||\n     (uintptr_t)exportArgs.share_handle + sizeof(SharedMemoryStruct->ShareHandle) <= (uintptr_t)SharedMemoryStruct->ShareHandle)) {\n    memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle, sizeof(SharedMemoryStruct->ShareHandle));\n} else {\n    // Handle error: overlapping regions or null pointers\n}\n```\nThis approach prevents undefined behavior by ensuring the memory regions do not overlap and are valid.\n\n## In Context Remediation 2\nIf overlapping memory regions are possible and cannot be ruled out, use memmove instead of memcpy, as memmove safely handles overlapping regions. Also, check for null pointers before the operation.\n\n```c\nif (SharedMemoryStruct->ShareHandle != NULL && exportArgs.share_handle != NULL) {\n    memmove(SharedMemoryStruct->ShareHandle, exportArgs.share_handle, sizeof(SharedMemoryStruct->ShareHandle));\n} else {\n    // Handle error: null pointers\n}\n```\nThis change ensures correct behavior even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms this as a genuine issue. The source and destination are both pointers, and the size calculation is not derived from a known safe capacity. The source and destination are also confirmed to be non-null, so the main risk is the potential for overlapping memory regions.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory regions that may overlap, add a runtime check to ensure the source and destination do not overlap before calling memcpy. If overlap is possible, use memmove instead, which is safe for overlapping regions.\n\n```c\nif ((process_apertures + (*num_of_nodes)) <= args_old.process_apertures ||\n    args_old.process_apertures + (*num_of_nodes) <= process_apertures) {\n    memcpy(process_apertures, args_old.process_apertures, sizeof(*process_apertures) * *num_of_nodes);\n} else {\n    memmove(process_apertures, args_old.process_apertures, sizeof(*process_apertures) * *num_of_nodes);\n}\n```\nThis approach ensures that memcpy is only used when the regions do not overlap, and memmove is used when overlap is possible.\n\n## In Context Remediation 2\nAlternatively, replace the memcpy call with memmove, which is designed to handle overlapping memory regions safely:\n\n```c\nmemmove(process_apertures, args_old.process_apertures, sizeof(*process_apertures) * *num_of_nodes);\n```\nThis change eliminates the risk of undefined behavior due to overlapping memory regions.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "42cb504a-a54f-37f6-b2c7-0359acdf02cc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not have the same risks as `alloca()`. However, remember to manually free the memory allocated by these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to replace `alloca()` with `malloc()`:\n\n```cpp\n// Old code\n// alloca(sizeof(*args) + s_attr)\n\n// New code\nvoid* args = malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // Handle error\n}\n// Use args\n// ...\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "706e0b01-e966-3ec0-aa0a-a8ab8eff5b74",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not have the same risks as `alloca()`. However, remember to manually free the memory allocated by these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to replace `alloca()` with `malloc()`:\n\n```cpp\n// Old code\n// alloca(sizeof(*args) + s_attr)\n\n// New code\nvoid* args = malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // Handle error\n}\n// Use args\n// ...\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8ae4f74-bb7b-3f82-ba07-2c4182eb1426",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(envvar)` with `std::stoi(envvar)`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    int value = std::stoi(envvar);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following library:\n\n- `<string>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "69528974-9557-3af4-b1d6-e65e3faca3c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlapping memory regions between the source and destination in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states an undefined behavior risk. The analysis determined that overlap is feasible based on data flow between the source and destination, which can cause unpredictable results with memcpy. Additionally, the source pointer may be null at this location, which further increases the risk of runtime errors. There are no explicit checks or guards in the code to prevent these issues, and the destination is a pointer type without a known fixed capacity. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory regions that may overlap, add a runtime check to ensure that the source and destination do not overlap before calling the memory copy function. If overlap is possible, use a safe copying strategy or a function that handles overlap correctly.\n\n```c\nif ((IoLinkProperties + NumIoLinks <= g_props[NodeId].link) || (g_props[NodeId].link + NumIoLinks <= IoLinkProperties)) {\n    memcpy(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n} else {\n    // Handle overlap safely, e.g., use memmove or copy in a way that avoids corruption\n}\n```\n\n\n## In Context Remediation 2\nAlternatively, replace the memory copy function with one that is designed to handle overlapping memory regions, such as memmove. This ensures correct behavior regardless of whether the source and destination overlap.\n\n```c\nmemmove(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8724d716-7d2c-384f-be32-aceffb1b609a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(envvar)` with `std::stoi(envvar)`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    int value = std::stoi(envvar);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following library:\n\n- `<string>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5fbafe64-db1f-3d28-983d-ab69ca7a4538",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ce474a51-40fc-3988-929a-d8b7d363c519",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source is not null, which could also lead to undefined behavior. The destination is not likely to be null, but the source may be. The use of a raw memory copy function without overlap checks or null pointer validation increases the risk of memory corruption or program crashes. These factors make this a high-confidence, actionable issue that should be addressed.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory regions that may overlap, add a runtime check to ensure the source and destination do not overlap before calling the memory copy function. If overlap is possible, use a safe copy function such as `memmove`, which is designed to handle overlapping regions safely.\n\n```c\nif ((char *)&tbl->cache[cache_cnt] <= (char *)this_cache + sizeof(HsaCacheProperties) &&\n    (char *)this_cache <= (char *)&tbl->cache[cache_cnt] + sizeof(HsaCacheProperties)) {\n    // Regions overlap, use memmove\n    memmove(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n} else {\n    // No overlap, safe to use memcpy\n    memcpy(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n}\n```\n\n\n## In Context Remediation 2\nAlternatively, replace the memory copy function with `memmove`, which is safe for overlapping memory regions. This change ensures that the operation is well-defined even if the source and destination overlap.\n\n```c\nmemmove(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "43269ca7-6c7b-3de1-a0ca-baceb393c22e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4c0fc642-84ab-3857-b748-1f90f6652957",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (sizeof(cpuinfo[proc].model_name) >= p_len) {\n    memcpy(cpuinfo[proc].model_name, p, p_len);\n} else {\n    // Handle error: source is too large for destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest and most trusted resources for secure coding practices."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5d485838-22c6-3d35-8c1a-809831d71766",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `atoi()` is considered unsafe because it does not check for overflow or invalid input, which can lead to unexpected behavior if the input is not a valid integer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using unsafe C functions and instead use safer alternatives that perform necessary checks. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the call to `atoi(p)` with the following code:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *end;\nlong val = strtol(p, &end, 10);\n\nif (errno == ERANGE) {\n    // handle overflow\n} else if (end == p) {\n    // handle invalid input\n} else {\n    // use val\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "04821794-63c6-3846-ba5c-6827bc3e3e21",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "30bb7a0c-8094-306f-8808-ce7f29b60266",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy()`, `strcat()`, and `strlen()`. Consider using safer alternatives that take the size of the buffer as a parameter, such as `strncpy()`, `strncat()`, and `strnlen()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(p)`, use `strnlen(p, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the buffer.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar p[MAX_LEN];\n\n// ... populate p with a string ...\n\nsize_t len = strnlen(p, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C and the `<cstring>` library in C++.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "91f26a41-7666-3622-9d5a-f523115909bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p) < HSA_PUBLIC_NAME_SIZE` vulnerability in C++ programming language is a potential buffer overflow vulnerability. This occurs when the length of the string pointed to by `p` is less than `HSA_PUBLIC_NAME_SIZE`. If an attacker can control the input to `p`, they can potentially cause a buffer overflow, leading to arbitrary code execution, application crashes, or other security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the buffer is sufficient to hold the data being copied into it. This includes the null-terminating character for strings. You should also validate and sanitize all input, especially if it comes from an untrusted source.\n\n## Source Code Fix Recommendation\n\nA potential fix for this vulnerability would be to use the `strncpy` function instead of `strlen`. This function allows you to specify the maximum number of characters to be copied, preventing a buffer overflow. Here is an example:\n\n```cpp\nchar p[HSA_PUBLIC_NAME_SIZE];\nstrncpy(p, input, HSA_PUBLIC_NAME_SIZE - 1);\np[HSA_PUBLIC_NAME_SIZE - 1] = '\\0';\n```\n\nIn this example, `input` is the string to be copied into `p`. The `strncpy` function copies at most `HSA_PUBLIC_NAME_SIZE - 1` characters, leaving room for the null-terminating character. The last line ensures that the string is properly null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used properly. In the provided code snippet, the `strlen(p) - 1` could potentially lead to a buffer underflow if the string `p` is empty. This is because `strlen(p)` would return 0 for an empty string, and subtracting 1 from it would result in -1, which is an invalid index.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in an array index. This can prevent buffer underflow and overflow vulnerabilities. Additionally, it is also recommended to use safer string handling functions that are bounds-checked to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (p && strlen(p) > 0) {\n    cpuinfo[proc].model_name[strlen(p) - 1] = '\\0';\n}\n```\n\nIn this fix, we first check if `p` is not null and if its length is greater than 0 before using it as an array index.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "426ae88f-c755-3104-837f-fd9b0ce29c99",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used correctly. In the provided code snippet, `strlen(p) - 1` is used as the length parameter for `strncpy()`. If the string `p` is empty, `strlen(p) - 1` will result in a large unsigned integer due to underflow, which can lead to buffer overflow when used in `strncpy()`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in functions like `strncpy()`. Also, it is a good practice to use safer string handling functions that automatically handle the null-terminating character and prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strlen(p);\nif (len > 0) {\n    strncpy(cpuinfo[proc].model_name, p, len - 1);\n    cpuinfo[proc].model_name[len - 1] = '\\0';\n} else {\n    cpuinfo[proc].model_name[0] = '\\0';\n}\n```\n\nIn this fix, we first check if the length of the string `p` is greater than 0. If it is, we proceed with the `strncpy()` operation and ensure that the destination string is null-terminated. If the length of `p` is 0, we simply set the first character of the destination string to the null character.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `cstring` or `string.h` for `strlen()` and `strncpy()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c4576fa7-b63a-3902-956d-fbc9f2becd8a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `atoi()` is considered unsafe because it does not check for overflow or invalid input, which can lead to unexpected behavior if the input is not a valid integer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using unsafe C functions and instead use safer alternatives that perform necessary checks. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the call to `atoi(p)` with the following code:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *end;\nlong val = strtol(p, &end, 10);\n\nif (errno == ERANGE) {\n    // handle overflow\n} else if (end == p) {\n    // handle invalid input\n} else {\n    // use val\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "698cbd9b-749b-3b09-a7c1-5116c776e12f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8145a0b5-5b2d-36fd-9cd7-2ff687e5f673",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is manipulated or if the file is not properly closed after use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fstream` objects from the C++ Standard Library, which automatically manage file resources and help prevent resource leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ifstream` object from the C++ Standard Library. Here is an example of how to do this:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string proc_cpuinfo_path;\n// ... (set proc_cpuinfo_path to the desired path)\nstd::ifstream file(proc_cpuinfo_path);\nif (!file) {\n    // Handle error\n}\n// Use file...\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for `std::ifstream`\n- `<string>`: for `std::string`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fa41aaa2-f960-3aa6-885a-073bf0d1df27",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. \n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly sanitized or validated. An attacker could potentially manipulate the `path` variable to read files they should not have access to, or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used to read and write files respectively. These classes provide more control and safety compared to the `fopen` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string path;\n// ... (set path to the desired file)\nstd::ifstream file(path);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file input/output operations\n- `<string>`: for string operations\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3ae0e89c-9fd2-3a00-9751-58e7bd62bb05",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For file operations, consider using the file stream classes (`fstream`, `ifstream`, `ofstream`) provided by the C++ Standard Library.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ifstream` class from the C++ Standard Library:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(KFD_SYSFS_PATH_SYSTEM_PROPERTIES);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library for file stream operations.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, it can lead to a buffer overflow vulnerability if the string is not null-terminated. In the provided code snippet, `strlen(shared_cpu_map)` could potentially lead to a buffer overflow if `shared_cpu_map` is not null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strnlen(shared_cpu_map, MAX_LENGTH);\nnum_hexs = (len + 8) / 9;\n```\n\nIn this fix, `strnlen` is used instead of `strlen` and `MAX_LENGTH` is a predefined constant that specifies the maximum length of `shared_cpu_map`.\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly indicate any library dependencies. However, the `strlen` function is part of the C Standard Library (`<cstring>` in C++).\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "84610a3a-bb7e-33ad-9664-6bb939bc33a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path or mode is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and error checking. For `fopen`, it is important to ensure that the file path and mode are properly controlled and cannot be manipulated by an attacker. \n\n## Source Code Fix Recommendation\n\nInstead of using `fopen`, you can use `fstream` in C++ which is safer and more flexible. Here is how you can do it:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(KFD_SYSFS_PATH_GENERATION_ID);\nif (!file) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` or `stdio.h` for `fopen`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "551db05f-4191-304c-ba82-101b0fbf8a70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `strtok()` is identified as a potential vulnerability sink. The `strtok()` function is used to split a string into tokens but it is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using `strtok()`. Instead, consider using safer alternatives such as `strtok_s()` or `strtok_r()`, which are thread-safe versions of `strtok()`. If these functions are not available, you may need to implement your own thread-safe tokenizing function.\n\n## Source Code Fix Recommendation\n\nReplace `strtok(NULL, \",\")` with `strtok_s(NULL, \",\", &next_token)` or `strtok_r(NULL, \",\", &next_token)`, where `next_token` is a pointer to a `char` pointer that is used to store the remainder of the string.\n\n```cpp\nchar *next_token = NULL;\nstrtok_s(NULL, \",\", &next_token);\n```\n\nor\n\n```cpp\nchar *next_token = NULL;\nstrtok_r(NULL, \",\", &next_token);\n```\n\n## Library Dependencies\n\nThe `strtok()`, `strtok_s()`, and `strtok_r()` functions are part of the C standard library (`<cstring>` or `<string.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9637b65f-b917-31a4-b45b-66a84500086d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the function `fopen` is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. For instance, you can use the `fopen_s` function which is a more secure version of `fopen`. It's also important to validate and control the file path that is passed to the `fopen` function to prevent path traversal attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fopen_s` function. Here is an example of how to do it:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, filename, \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` or `cstdio` library to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5e15bafc-396a-32ba-869c-6c22809cc61e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the `strtok` function is used, which is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strtok`. Instead, use thread-safe alternatives such as `strtok_r` or `strtok_s` if available. Also, consider using higher-level string parsing functions provided by the C++ Standard Library, which are generally safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strtok` function with a thread-safe alternative. Here is an example of how you can do this with `strtok_r`:\n\n```cpp\nchar *shared_cpu_map;\nchar *saveptr;\nchar *token = strtok_r(shared_cpu_map, \",\", &saveptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstring` or `string.h` for `strtok` function\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5992352b-4a56-3a14-9d66-50a3ec72d8b0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the function `fopen` is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. For instance, you can use the `fopen_s` function which is a more secure version of `fopen`. It's also important to validate and control the file path that is passed to the `fopen` function to prevent path traversal attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fopen_s` function. Here is an example of how to do it:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, filename, \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` or `cstdio` library to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d9ecf8ac-935f-3eeb-b7d0-e680befd72df",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the function `fopen` is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. For instance, you can use the `fopen_s` function which is a more secure version of `fopen`. It's also important to validate and control the file path that is passed to the `fopen` function to prevent path traversal attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fopen_s` function. Here is an example of how to do it:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, filename, \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` or `cstdio` library to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate the string for you.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nprefix_len = strlen(prefix);\n```\n\nYou could use:\n\n```cpp\nprefix_len = strnlen(prefix, MAX_PREFIX_LEN);\n```\n\nWhere `MAX_PREFIX_LEN` is the maximum expected length of the prefix.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict for this call site is marked as genuine. The code copies memory from a function result to a destination pointer, but there are no visible checks to ensure that the source pointer returned by the function is not null. The analysis also conservatively reports that the source may be null, which could lead to a crash or other undefined behavior if memcpy is called with a null source. The destination is less likely to be null, but the main risk is with the source. No overlap between source and destination is detected, so the primary concern is null pointer safety.\n\n## In Context Remediation 1\nBefore calling the memory copy operation, ensure that the source pointer returned by the function is not null. Add an explicit check and handle the error appropriately to prevent undefined behavior.\n\n```c\nvoid *src = convert_queue_ids(num_queues, Queues);\nif (src == NULL) {\n    // Handle error: log, return, or take corrective action\n    return;\n}\nmemcpy(queue_ptr, src, num_queues * sizeof(uint32_t));\n```\n\nThis ensures that the memory copy only occurs if the source pointer is valid, preventing a potential crash or undefined behavior if the function fails to allocate or return a valid pointer.\n\n## In Context Remediation 2\nIf there is any possibility that the destination pointer could also be null, add a check for the destination as well:\n\n```c\nvoid *src = convert_queue_ids(num_queues, Queues);\nif (src == NULL || queue_ptr == NULL) {\n    // Handle error: log, return, or take corrective action\n    return;\n}\nmemcpy(queue_ptr, src, num_queues * sizeof(uint32_t));\n```\n\nThis provides full protection against null pointer dereference for both source and destination pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results when using memory copy functions that do not support overlapping regions. Additionally, the destination pointer may be null, increasing the risk of a crash. There are no explicit checks to ensure the destination is valid or that the regions do not overlap. The source is confirmed to be non-null before the call, but this does not mitigate the overlap risk. The function used is not safe for overlapping memory regions, and the absence of guards or capacity checks further increases the risk.\n\n## In Context Remediation 1\nAdd explicit checks to ensure that the source and destination memory regions do not overlap before performing the memory copy. If overlap is possible, use a safe memory move function instead. For example:\n\n```c\nif (q->cu_mask != QueueCUMask &&\n    ((q->cu_mask + (CUMaskCount / 8) <= QueueCUMask) ||\n     (QueueCUMask + (CUMaskCount / 8) <= q->cu_mask))) {\n    memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n} else {\n    // Handle overlap safely, e.g., use memmove\n    memmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n}\n```\nThis ensures that memcpy is only used when the regions do not overlap, and memmove is used otherwise.\n\n## In Context Remediation 2\nReplace the memory copy operation with a memory move function that is safe for overlapping regions:\n\n```c\nmemmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n```\nThis change ensures that the operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f7699bec-8673-3506-8e3a-8dbb5d28ae5b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function in question is `alloca()`. \n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, as the amount of space available on the stack is much less than that available on the heap. Moreover, there is no way to detect such an overflow, which can lead to undefined behavior and potential security risks.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions return a null pointer if they fail, allowing the failure to be detected and handled.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca(s_attr)` call with a `malloc(s_attr)` call and add error checking:\n\n```cpp\nchar* buffer = (char*) malloc(s_attr);\nif (buffer == NULL) {\n    // handle error\n}\n// use buffer\nfree(buffer);\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the standard C library, so no additional library dependencies are required.\n\n## References\n\n- [CWE-770: Allocation of Resources Without Limits or Throttling](https://cwe.mitre.org/data/definitions/770.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "943d24b2-b801-3716-aaa2-0158eac068aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 5,
                  "endLine": 206,
                  "endColumn": 13,
                  "charOffset": 6316,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "26278970-c011-3c6c-aecc-cf13aa48a718",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 5,
                  "endLine": 202,
                  "endColumn": 13,
                  "charOffset": 6177,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 35,
                  "charOffset": 4275,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4275,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "40bcd266-2384-3785-9486-008baf1aa5fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 1,
                  "endLine": 252,
                  "endColumn": 35,
                  "charOffset": 6680,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6680,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f35ef05-841d-36ee-9390-16e19706cec2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 8,
                  "endLine": 247,
                  "endColumn": 14,
                  "charOffset": 6514,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a6eed958-abde-35f1-a910-0850a3663f57",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 14,
                  "charOffset": 2052,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 35,
                  "charOffset": 5079,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(attrs, args->attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(attrs, args->attrs, s_attr)",
                      "markdown": "`memcpy(attrs, args->attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5079,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(attrs, <size of attrs>,  args->attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eab60fa1-363d-3f93-892e-e0dcfd1cc67c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 8,
                  "endLine": 128,
                  "endColumn": 14,
                  "charOffset": 4118,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "867a2739-0b84-34c7-a9b3-fad7bee50348",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3817,
                  "startColumn": 1,
                  "endLine": 3818,
                  "endColumn": 34,
                  "charOffset": 111548,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                    "rendered": {
                      "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                      "markdown": "`memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111548,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(importArgs.share_handle, <size of importArgs.share_handle>,  SharedMemoryStruct->ShareHandle, \n\t\t\tsizeof(importArgs.share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "875b8707-13df-33f0-9548-f0b927d5ba5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 1,
                  "endLine": 67,
                  "endColumn": 35,
                  "charOffset": 2209,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2209,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2962,
                  "startColumn": 1,
                  "endLine": 2964,
                  "endColumn": 29,
                  "charOffset": 85760,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                    "rendered": {
                      "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                      "markdown": "`memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85760,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)], <size of &obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)]>, \n\t\t\tids_array,  ids_array_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3787,
                  "startColumn": 1,
                  "endLine": 3788,
                  "endColumn": 42,
                  "charOffset": 110495,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                    "rendered": {
                      "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                      "markdown": "`memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 110495,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(SharedMemoryStruct->ShareHandle, <size of SharedMemoryStruct->ShareHandle>,  exportArgs.share_handle, \n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2042,
                  "startColumn": 1,
                  "endLine": 2043,
                  "endColumn": 34,
                  "charOffset": 56906,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                    "rendered": {
                      "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                      "markdown": "`memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56906,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(process_apertures, <size of process_apertures>,  args_old.process_apertures, \n\t       sizeof(*process_apertures)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1762,
                  "startColumn": 8,
                  "endLine": 1762,
                  "endColumn": 16,
                  "charOffset": 49213,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "42cb504a-a54f-37f6-b2c7-0359acdf02cc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1073,
                  "startColumn": 8,
                  "endLine": 1073,
                  "endColumn": 14,
                  "charOffset": 30148,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "706e0b01-e966-3ec0-aa0a-a8ab8eff5b74",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1038,
                  "startColumn": 8,
                  "endLine": 1038,
                  "endColumn": 14,
                  "charOffset": 28986,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8ae4f74-bb7b-3f82-ba07-2c4182eb1426",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 20,
                  "charOffset": 3872,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "69528974-9557-3af4-b1d6-e65e3faca3c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 1,
                  "endLine": 2394,
                  "endColumn": 46,
                  "charOffset": 70810,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                    "rendered": {
                      "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                      "markdown": "`memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70810,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(IoLinkProperties, <size of IoLinkProperties>,  g_props[NodeId].link, \n\t       NumIoLinks * sizeof(*IoLinkProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8724d716-7d2c-384f-be32-aceffb1b609a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 16,
                  "endLine": 135,
                  "endColumn": 20,
                  "charOffset": 3617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5fbafe64-db1f-3d28-983d-ab69ca7a4538",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1634,
                  "startColumn": 6,
                  "endLine": 1634,
                  "endColumn": 11,
                  "charOffset": 49008,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ce474a51-40fc-3988-929a-d8b7d363c519",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1533,
                  "startColumn": 6,
                  "endLine": 1533,
                  "endColumn": 11,
                  "charOffset": 45857,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1499,
                  "startColumn": 3,
                  "endLine": 1501,
                  "endColumn": 36,
                  "charOffset": 45055,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                    "rendered": {
                      "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                      "markdown": "`memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45055,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tbl->cache[cache_cnt++], <size of &tbl->cache[cache_cnt++]>, \n\t\t\t       this_cache, \n\t\t\t       sizeof(HsaCacheProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "43269ca7-6c7b-3de1-a0ca-baceb393c22e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1298,
                  "startColumn": 6,
                  "endLine": 1298,
                  "endColumn": 11,
                  "charOffset": 38756,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4c0fc642-84ab-3857-b748-1f90f6652957",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 26,
                  "endLine": 997,
                  "endColumn": 30,
                  "charOffset": 28797,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 988,
                  "startColumn": 3,
                  "endLine": 988,
                  "endColumn": 45,
                  "charOffset": 28528,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                    "rendered": {
                      "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                      "markdown": "`memcpy(cpuinfo[proc].model_name, p, p_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28528,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cpuinfo[proc].model_name, <size of cpuinfo[proc].model_name>,  p,  p_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5d485838-22c6-3d35-8c1a-809831d71766",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1448,
                  "startColumn": 23,
                  "endLine": 1448,
                  "endColumn": 27,
                  "charOffset": 43524,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "04821794-63c6-3846-ba5c-6827bc3e3e21",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1095,
                  "startColumn": 6,
                  "endLine": 1095,
                  "endColumn": 11,
                  "charOffset": 31141,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "30bb7a0c-8094-306f-8808-ce7f29b60266",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 985,
                  "startColumn": 11,
                  "endLine": 985,
                  "endColumn": 20,
                  "charOffset": 28443,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91f26a41-7666-3622-9d5a-f523115909bd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 962,
                  "startColumn": 10,
                  "endLine": 962,
                  "endColumn": 14,
                  "charOffset": 27838,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 7,
                  "endLine": 941,
                  "endColumn": 16,
                  "charOffset": 27131,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 29,
                  "endLine": 944,
                  "endColumn": 38,
                  "charOffset": 27286,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "426ae88f-c755-3104-837f-fd9b0ce29c99",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 943,
                  "startColumn": 41,
                  "endLine": 943,
                  "endColumn": 50,
                  "charOffset": 27241,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c4576fa7-b63a-3902-956d-fbc9f2becd8a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 10,
                  "endLine": 919,
                  "endColumn": 14,
                  "charOffset": 26617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "698cbd9b-749b-3b09-a7c1-5116c776e12f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 666,
                  "startColumn": 6,
                  "endLine": 666,
                  "endColumn": 11,
                  "charOffset": 19939,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8145a0b5-5b2d-36fd-9cd7-2ff687e5f673",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 6,
                  "endLine": 898,
                  "endColumn": 11,
                  "charOffset": 25994,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fa41aaa2-f960-3aa6-885a-073bf0d1df27",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 614,
                  "startColumn": 6,
                  "endLine": 614,
                  "endColumn": 11,
                  "charOffset": 18507,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3ae0e89c-9fd2-3a00-9751-58e7bd62bb05",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 723,
                  "startColumn": 6,
                  "endLine": 723,
                  "endColumn": 11,
                  "charOffset": 21212,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 13,
                  "endLine": 467,
                  "endColumn": 35,
                  "charOffset": 13980,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(shared_cpu_map)",
                    "rendered": {
                      "text": "strlen(shared_cpu_map)",
                      "markdown": "`strlen(shared_cpu_map)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "84610a3a-bb7e-33ad-9664-6bb939bc33a5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 584,
                  "startColumn": 6,
                  "endLine": 584,
                  "endColumn": 11,
                  "charOffset": 17750,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "551db05f-4191-304c-ba82-101b0fbf8a70",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 483,
                  "startColumn": 11,
                  "endLine": 483,
                  "endColumn": 17,
                  "charOffset": 14479,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9637b65f-b917-31a4-b45b-66a84500086d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 372,
                  "startColumn": 6,
                  "endLine": 372,
                  "endColumn": 11,
                  "charOffset": 11767,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5e15bafc-396a-32ba-869c-6c22809cc61e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 468,
                  "startColumn": 10,
                  "endLine": 468,
                  "endColumn": 16,
                  "charOffset": 14048,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5992352b-4a56-3a14-9d66-50a3ec72d8b0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 420,
                  "startColumn": 6,
                  "endLine": 420,
                  "endColumn": 11,
                  "charOffset": 12834,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d9ecf8ac-935f-3eeb-b7d0-e680befd72df",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 6,
                  "endLine": 395,
                  "endColumn": 11,
                  "charOffset": 12280,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 18,
                  "endLine": 344,
                  "endColumn": 32,
                  "charOffset": 11181,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(prefix)",
                    "rendered": {
                      "text": "strlen(prefix)",
                      "markdown": "`strlen(prefix)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 549,
                  "startColumn": 11,
                  "endLine": 549,
                  "endColumn": 19,
                  "charOffset": 14844,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 2,
                  "endLine": 532,
                  "endColumn": 57,
                  "charOffset": 14449,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                    "rendered": {
                      "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                      "markdown": "`memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14449,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(queue_ptr, <size of queue_ptr>,  convert_queue_ids(num_queues,  Queues)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 810,
                  "startColumn": 1,
                  "endLine": 810,
                  "endColumn": 49,
                  "charOffset": 21859,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                    "rendered": {
                      "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                      "markdown": "`memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21859,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(q->cu_mask, <size of q->cu_mask>,  QueueCUMask,  CUMaskCount / 8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f7699bec-8673-3506-8e3a-8dbb5d28ae5b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 30,
                  "endLine": 439,
                  "endColumn": 36,
                  "charOffset": 11571,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}