{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "26278970-c011-3c6c-aecc-cf13aa48a718",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "943d24b2-b801-3716-aaa2-0158eac068aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code performs a memory copy operation without any visible checks to ensure that the source pointer returned by the function `convert_queue_ids(num_queues, Queues)` is not null. If this function returns a null pointer, passing it to `memcpy` will result in undefined behavior, which can lead to program crashes or security vulnerabilities. The destination pointer is less likely to be null, but the main risk is with the source. No guard or validation is present before the copy, and the analysis could not confirm that the source is always valid. This makes the issue actionable and in need of remediation.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source pointer returned by `convert_queue_ids(num_queues, Queues)` is not null. This prevents undefined behavior if the function fails or returns a null pointer. For example:\n\n```c\nuint32_t *src_ptr = convert_queue_ids(num_queues, Queues);\nif (src_ptr != NULL) {\n    memcpy(queue_ptr, src_ptr, num_queues * sizeof(uint32_t));\n} else {\n    // Handle error: source pointer is null\n}\n```\nThis check ensures that the memory copy only occurs when the source is valid, preventing crashes or security issues due to null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap in memory. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. This can lead to undefined behavior according to the C standard, as memcpy is not safe for overlapping regions. There are no explicit checks or guards in the code to prevent this overlap, and the types involved are pointers, making it difficult to guarantee non-overlapping memory. The source and destination are both non-null, so null pointer dereference is not a concern here. The risk is specifically related to undefined behavior from overlapping memory regions during the copy operation.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination buffers safely. Replace the original call with:\n\n```c\nmemmove(attrs, args->attrs, s_attr);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "40bcd266-2384-3785-9486-008baf1aa5fa",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. No explicit bounds or guards are present to mitigate these risks. The source and destination are both identifiers, and the overlap is confirmed via dataflow, making this a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```c\nmemmove(args->attrs, attrs, s_attr);\n```\n\nAdditionally, ensure that both `args->attrs` and `attrs` are not null before performing the copy to avoid null pointer dereference:\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ae7e02d7-0f9d-3fe1-90c8-595f3f1d3085",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fb423e8e-785a-389f-8aca-3653f0cd57fa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "875b8707-13df-33f0-9548-f0b927d5ba5f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source are both identifiers, and dataflow analysis suggests that the destination may be derived from the source, making overlap feasible. Additionally, there are no explicit checks to ensure that the source and destination are not null, which increases the risk of undefined behavior. The absence of a guard or capacity check further supports the assessment that this is a real issue. The probability of this being a false positive is low, as the overlap is confirmed by dataflow analysis and there are no mitigating factors such as string literals or explicit guards.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null checks for both the source and destination pointers before performing the copy to avoid null pointer dereference.\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ba3d4613-16f8-3bf9-ba24-d38657d988bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no explicit checks to ensure that the source and destination are non-null, increasing the risk of null pointer dereference. The absence of guards or evidence that the copy size is safe further supports the assessment that this is a real issue requiring remediation.\n\n## In Context Remediation\nTo remediate the undefined behavior risk caused by possible overlapping memory regions, ensure that the source and destination buffers do not overlap before performing the memory copy. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null pointer checks for both the source and destination to prevent null pointer dereference vulnerabilities.\n\n```c\nif (args->attrs != NULL && attrs != NULL) {\n    memmove(args->attrs, attrs, s_attr);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "867a2739-0b84-34c7-a9b3-fad7bee50348",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis suggests that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no explicit checks to ensure that the source and destination are non-null, increasing the risk of null pointer dereference. The use of sizeof on the destination for the copy length is correct, but it does not mitigate the overlap risk. The source is not a string literal or constant, so the overlap risk is not reduced. No guards or capacity checks are present to further reduce the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```c\nmemmove(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n```\n\nAdditionally, ensure that both `importArgs.share_handle` and `SharedMemoryStruct->ShareHandle` are not null before performing the copy to avoid null pointer dereference:\n\n```c\nif (importArgs.share_handle != NULL && SharedMemoryStruct->ShareHandle != NULL) {\n    memmove(importArgs.share_handle, SharedMemoryStruct->ShareHandle, sizeof(importArgs.share_handle));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory, and this can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null, which further increases the risk. The classification specifically highlights undefined behavior due to possible overlap, and the verdict is marked as genuine. The source is a general identifier, not a string literal or constant, so the risk of overlap is not reduced by the nature of the source.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using memcpy. If there is any possibility of overlap, use memmove instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```c\nmemmove(&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)], ids_array, ids_array_size);\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy:\n\n```c\nif (ids_array != NULL) {\n    memmove(&obj->mapped_device_id_array[obj->mapped_device_id_array_size/sizeof(uint32_t)], ids_array, ids_array_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory through data flow, which can cause undefined behavior when using functions like memcpy. Additionally, there are no explicit checks to ensure that the source and destination are non-overlapping or non-null, increasing the risk. The absence of guards for null pointers further elevates the risk of runtime errors or crashes. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null dereference errors.\n\n```c\nif (SharedMemoryStruct && exportArgs.share_handle) {\n    memmove(SharedMemoryStruct->ShareHandle, exportArgs.share_handle, sizeof(SharedMemoryStruct->ShareHandle));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "30cefb5e-6d04-3d68-9853-92409d953d79",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to potential issues if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv` function directly without proper validation and error checking. If you must use it, ensure that the returned value is not null before using it. Also, be aware that the returned string may be modified by subsequent calls to `getenv`, `setenv`, or `putenv`.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar* maxVaAlignStr = getenv(\"HSA_MAX_VA_ALIGN\");\nif(maxVaAlignStr == NULL) {\n    // Handle the error, e.g., by using a default value\n    maxVaAlignStr = \"default_value\";\n}\n```\n\n## Library Dependencies\n\nThe `getenv` function is part of the C Standard Library (libc), so no additional libraries are required.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d0d81761-f442-3181-952c-25f46e587e08",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to potential issues if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using the `getenv` function. If you need to use environment variables, consider using a safer alternative that does not have the same vulnerabilities. Validate all input and never trust data from untrusted sources. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a safer alternative. For example, you could use the `std::getenv` function from the C++ standard library, which is considered safer:\n\n```cpp\n#include <cstdlib>\n\nconst char* guardPagesStr = std::getenv(\"HSA_SVM_GUARD_PAGES\");\nif (!guardPagesStr) {\n    // Handle the case where the environment variable is not set\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstdlib`\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "eca34812-b7c8-3a0e-a779-3d5eacb2aa7f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `getenv` is used, which can lead to security vulnerabilities as it returns a pointer to a string that represents the value for the environment variable passed as input. This string can be altered by an attacker, leading to potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using the `getenv` function. Instead, use safer alternatives that do not have the same vulnerabilities. For example, consider using a function that copies the environment variable into a buffer that you control, so that you can ensure that it is not overwritten by an attacker.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how you can modify the code:\n\n```cpp\nchar* reserveSvm;\nsize_t requiredSize;\ngetenv_s(&requiredSize, NULL, 0, \"HSA_RESERVE_SVM\");\nif (requiredSize == 0)\n{\n    printf(\"HSA_RESERVE_SVM not found\\n\");\n    exit(1);\n}\nreserveSvm = (char*)malloc(requiredSize * sizeof(char));\ngetenv_s(&requiredSize, reserveSvm, requiredSize, \"HSA_RESERVE_SVM\");\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `getenv` and `exit` functions\n- `stdio.h` for `printf` function\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a call to a memory copying function. The destination and source buffers may overlap, as indicated by the dataflow analysis, which can lead to unpredictable results or program crashes. The source and destination are both pointers, and there is no evidence of a guard or explicit check to prevent overlap. Although the source and destination are not null, the main concern is the potential for memory regions to overlap, which is not allowed for memcpy and can result in undefined behavior. This issue should be addressed to ensure memory safety and program correctness.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination buffers safely. Replace the original call with:\n\n```c\nmemmove(process_apertures, args_old.process_apertures, sizeof(*process_apertures) * *num_of_nodes);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "407d9301-f127-36b4-b584-29bfc2978455",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3fc850f2-be94-3c63-b81f-d93e57e19f6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to introduce vulnerabilities into the code. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This function is considered unsafe because it can lead to buffer overflow vulnerabilities if not used carefully. Buffer overflow vulnerabilities can allow an attacker to execute arbitrary code, leading to a potential security breach.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()` or `calloc()`, which allocate memory on the heap and are generally safer. Always ensure to check the return value of these functions to make sure that the memory allocation was successful. Also, always free the memory that was allocated when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()` or `calloc()`. Here is how you can do it:\n\n```cpp\nargs = (arg_type*) malloc(sizeof(*args) + s_attr);\nif (args == NULL) {\n    // handle error\n}\n```\n\nDon't forget to free the allocated memory when it's no longer needed:\n\n```cpp\nfree(args);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is defined in the `alloca.h` header file. The `malloc()`, `calloc()`, and `free()` functions are defined in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cd5982ad-651e-3147-b69c-c88d71b409aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that represents the value for the environment variable passed as input. If an attacker can control the environment, they can manipulate the output of this function.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a method that does not allow an attacker to control the environment.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nconst char* checkUserptr = std::getenv(\"HSA_CHECK_USERPTR\");\nif (checkUserptr == nullptr) {\n    // Handle the case where the environment variable is not set.\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "58ab4d8e-ec12-3df3-a740-b80deb4cf35b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `getenv()` is used, which can lead to security vulnerabilities if not used carefully. This function returns a pointer to a string that represents the value of the environment variable passed as input. If an attacker can modify this environment variable, they can control the output of the `getenv()` function, leading to potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv()` function if possible. If you must use it, ensure that you validate and sanitize its output before using it. Never trust the output of `getenv()` without validation, as it can be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv()`, consider using a safer alternative that allows for error handling or bounds checking. If you must use `getenv()`, validate its output before using it. Here's an example of how you might do this:\n\n```cpp\nconst char* disableCache = getenv(\"HSA_DISABLE_CACHE\");\nif (disableCache == NULL) {\n    // Handle error: environment variable not found\n} else {\n    // Validate and sanitize disableCache before using it\n}\n```\n\n## Library Dependencies\n\nThe `getenv()` function is part of the C standard library, so you'll need to include `cstdlib` to use it:\n\n```cpp\n#include <cstdlib>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "48128d6d-353f-3c70-8f68-a71cdc93f5c5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prohibited because they can lead to various security issues such as buffer overflows, format string vulnerabilities, or other types of memory corruption. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities.\n\nThe `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This function is not thread-safe and can lead to race conditions. Moreover, the returned pointer might be invalidated or the string content might be overwritten by subsequent calls to `getenv`, `setenv`, or `unsetenv`.\n\n## Mitigation Advice\n\nAvoid using `getenv` function. If you need to use environment variables, consider using a thread-safe and reentrant function. Also, ensure that the environment variable is not controlled by an untrusted user to prevent potential security risks.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nchar* pagedUserptr;\nchar* envVar = std::getenv(\"HSA_USERPTR_FOR_PAGED_MEM\");\nif(envVar != nullptr)\n{\n    pagedUserptr = strdup(envVar);\n}\n```\n\nIn this code, we use `std::getenv` which is a safer version of `getenv`. We also check if the returned pointer is not null before using it.\n\n## Library Dependencies\n\nThe code requires the `cstdlib` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. There is no evidence of a guard or check to prevent this overlap, and the destination pointer may also be null, increasing the risk. The source is not a string literal or constant, so the overlap risk is not mitigated. This issue should be addressed to prevent potential memory corruption or unpredictable program behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination buffers safely. Replace the original call with:\n\n```c\nmemmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n```\n\nAdditionally, ensure that both `q->cu_mask` and `QueueCUMask` are valid pointers and that the destination buffer is large enough to hold `CUMaskCount / 8` bytes. If there is a possibility that the destination pointer could be null, add a check before the call:\n\n```c\nif (q->cu_mask != NULL && QueueCUMask != NULL) {\n    memmove(q->cu_mask, QueueCUMask, CUMaskCount / 8);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "69528974-9557-3af4-b1d6-e65e3faca3c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlapping memory regions between the source and destination in the memory copy operation. The destination and source expressions are not simple string literals or constant arrays, and dataflow analysis suggests that the source and destination may alias each other. Additionally, there is no explicit guard or check to prevent overlap, and the source pointer could potentially be null, which further increases the risk. The use of memcpy in this context is unsafe if the regions overlap, as it can lead to unpredictable program behavior or data corruption. The probability of this being a false positive is low, as the overlap risk is supported by dataflow evidence and there are no mitigating signals present.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping source and destination buffers safely. This change ensures that the copy operation will not corrupt data even if the regions overlap.\n\n```c\nmemmove(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n```\n\nAlternatively, if you can guarantee that the source and destination never overlap, document this assumption clearly in the code and add an assertion to enforce it at runtime:\n\n```c\nassert(IoLinkProperties != g_props[NodeId].link);\nmemcpy(IoLinkProperties, g_props[NodeId].link, NumIoLinks * sizeof(*IoLinkProperties));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3716c81a-54dd-322b-b4fa-2740a8302451",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `alloca()` function is used, which is considered unsafe because it allocates memory on the stack, which can lead to stack overflow if the size is too large.\n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions are safer because they do not risk a stack overflow. However, remember to always check the return value of these functions to ensure that the memory allocation was successful, and always free the memory when you're done using it to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how you can do it:\n\n```cpp\n// Old code\nattrs = (HSA_SVM_ATTRIBUTE *)alloca(s_attr);\n\n// New code\nattrs = (HSA_SVM_ATTRIBUTE *)malloc(s_attr);\nif (attrs == NULL) {\n    // Handle error\n}\n// Remember to free the memory when you're done\nfree(attrs);\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc()` and `free()` functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "614e7e2e-f37f-3862-ada9-97b129700396",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8a5c755-347b-37e9-a6a0-c3cae1530489",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "de3d036a-fa99-3cd3-b5d7-6949c6bc7e8e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may refer to overlapping memory areas, which can cause undefined behavior with functions like memcpy. The source is an identifier, and dataflow analysis suggests a possible overlap. There is no evidence of a guard or explicit check to prevent this overlap, and the source may also be null, increasing the risk. The destination is not a pointer-based member, which slightly reduces the risk, but the overlap concern remains the primary issue. No mitigating factors such as guards or capacity checks are present.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using `memcpy`. If there is any possibility of overlap, use `memmove` instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```c\nmemmove(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n```\n\nAlternatively, add logic to ensure that the source and destination do not overlap before performing the copy. Always validate that the source pointer is not null before copying to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8d42967b-3f84-3ec3-b570-8e989712fe84",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c89176f3-6bcb-3726-9ca2-c0d728e38099",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or other security issues if the environment variable contains sensitive information.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. If you must use a potentially insecure function, make sure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nchar* temp = std::getenv(per_node_override);\nif(temp != nullptr)\n    envvar = temp;\nelse {\n    temp = std::getenv(\"HSA_OVERRIDE_GFX_VERSION\");\n    if(temp != nullptr)\n        envvar = temp;\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "c89176f3-6bcb-3726-9ca2-c0d728e38099"
                ]
              }
            },
            {
              "id": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may refer to overlapping memory areas, which can cause undefined behavior with functions like memcpy. The source is an identifier, and dataflow analysis suggests a possible overlap. There is no evidence of a guard or explicit check to prevent this overlap, and the source may also be null, increasing the risk. The destination is not a pointer-based member, which slightly reduces the risk, but the overlap concern remains the primary issue. No mitigating factors such as guards or capacity checks are present.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using `memcpy`. If there is any possibility of overlap, use `memmove` instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```c\nmemmove(&tbl->cache[cache_cnt++], this_cache, sizeof(HsaCacheProperties));\n```\n\nAlternatively, add logic to ensure that the source and destination do not overlap before performing the copy. Always validate that the source pointer is not null before copying to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fefc2180-ca00-3d29-806b-78df341f3d32",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function as it does not check for errors. Instead, use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent any malicious data from causing harm.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is the fixed code:\n\n```cpp\nchar *end;\nlong proc_num = strtol(p, &end, 10);\nif (end == p || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    this_cpu->proc_num = proc_num;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4c0fc642-84ab-3857-b748-1f90f6652957",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "30bb7a0c-8094-306f-8808-ce7f29b60266",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy()`, `strcat()`, and `strlen()`. Consider using safer alternatives that take the size of the buffer as a parameter, such as `strncpy()`, `strncat()`, and `strnlen()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(p)`, use `strnlen(p, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the buffer.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar p[MAX_LEN];\n\n// ... populate p with a string ...\n\nsize_t len = strnlen(p, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C and the `<cstring>` library in C++.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "900eaf87-52d6-3975-95f7-702bb2bdafaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or other security issues if the environment variable contains sensitive information.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. If you must use a potentially insecure function, make sure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nchar* temp = std::getenv(per_node_override);\nif(temp != nullptr)\n    envvar = temp;\nelse {\n    temp = std::getenv(\"HSA_OVERRIDE_GFX_VERSION\");\n    if(temp != nullptr)\n        envvar = temp;\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "900eaf87-52d6-3975-95f7-702bb2bdafaa"
                ]
              }
            },
            {
              "id": "91f26a41-7666-3622-9d5a-f523115909bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used properly. In the provided code snippet, the `strlen(p) - 1` could potentially lead to a buffer underflow if the string `p` is empty. This is because `strlen(p)` would return 0 for an empty string, and subtracting 1 from it would result in -1, which is an invalid index.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in an array index. This can prevent buffer underflow and overflow vulnerabilities. Additionally, it is also recommended to use safer string handling functions that are bounds-checked to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (p && strlen(p) > 0) {\n    cpuinfo[proc].model_name[strlen(p) - 1] = '\\0';\n}\n```\n\nIn this fix, we first check if `p` is not null and if its length is greater than 0 before using it as an array index.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p) < HSA_PUBLIC_NAME_SIZE` vulnerability in C++ programming language is a potential buffer overflow vulnerability. This occurs when the length of the string pointed to by `p` is less than `HSA_PUBLIC_NAME_SIZE`. If an attacker can control the input to `p`, they can potentially cause a buffer overflow, leading to arbitrary code execution, application crashes, or other security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the buffer is sufficient to hold the data being copied into it. This includes the null-terminating character for strings. You should also validate and sanitize all input, especially if it comes from an untrusted source.\n\n## Source Code Fix Recommendation\n\nA potential fix for this vulnerability would be to use the `strncpy` function instead of `strlen`. This function allows you to specify the maximum number of characters to be copied, preventing a buffer overflow. Here is an example:\n\n```cpp\nchar p[HSA_PUBLIC_NAME_SIZE];\nstrncpy(p, input, HSA_PUBLIC_NAME_SIZE - 1);\np[HSA_PUBLIC_NAME_SIZE - 1] = '\\0';\n```\n\nIn this example, `input` is the string to be copied into `p`. The `strncpy` function copies at most `HSA_PUBLIC_NAME_SIZE - 1` characters, leaving room for the null-terminating character. The last line ensures that the string is properly null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "426ae88f-c755-3104-837f-fd9b0ce29c99",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. The `strlen()` function is used to find the length of a string. However, it can lead to buffer overflow vulnerabilities if not used correctly. In the provided code snippet, `strlen(p) - 1` is used as the length parameter for `strncpy()`. If the string `p` is empty, `strlen(p) - 1` will result in a large unsigned integer due to underflow, which can lead to buffer overflow when used in `strncpy()`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the length of the string before using it in functions like `strncpy()`. Also, it is a good practice to use safer string handling functions that automatically handle the null-terminating character and prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strlen(p);\nif (len > 0) {\n    strncpy(cpuinfo[proc].model_name, p, len - 1);\n    cpuinfo[proc].model_name[len - 1] = '\\0';\n} else {\n    cpuinfo[proc].model_name[0] = '\\0';\n}\n```\n\nIn this fix, we first check if the length of the string `p` is greater than 0. If it is, we proceed with the `strncpy()` operation and ensure that the destination string is null-terminated. If the length of `p` is 0, we simply set the first character of the destination string to the null character.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `cstring` or `string.h` for `strlen()` and `strncpy()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "ebea03cb-c3f6-371b-8288-682e5632a34d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "53ad4208-6dae-3658-9f0e-e447d212d367",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the `path` variable is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate the `path` variable to ensure it does not contain any malicious values that could lead to a path traversal or file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(path);\nif (!file) {\n    // handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This class provides a higher level of abstraction and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a245924f-4407-3779-9db4-e8cb4ceb6389",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can lead to a security risk. In this case, the function `atoi()` is used, which converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the string cannot be converted to an integer, it returns zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace the `atoi()` function with a function that performs error checking, such as `strtol()`. This function allows you to check if the entire string was converted to an integer and if any errors occurred during the conversion.\n\n## Source Code Fix Recommendation\n\nHere is how you can replace `atoi()` with `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *p;\nlong int proc;\nchar *endptr;\n\nerrno = 0;    /* To distinguish success/failure after call */\nproc = strtol(p, &endptr, 10);\n\n/* Check for various possible errors */\n\nif ((errno == ERANGE && (proc == LONG_MAX || proc == LONG_MIN))\n        || (errno != 0 && proc == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == p) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n/* If we got here, strtol() successfully parsed a number */\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e226928f-9961-33b5-9e79-3fc4fe5cae72",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path or mode string is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to implement proper validation and error handling. In the case of `fopen`, consider using a function that allows for more control over file permissions, or ensure that the file path and mode string are properly validated and controlled.\n\n## Source Code Fix Recommendation\n\n```cpp\n#define KFD_SYSFS_PATH_SYSTEM_PROPERTIES \"/sys/class/kfd/kfd/topology/system_properties\"\n\nFILE *fd;\nif((fd = fopen(KFD_SYSFS_PATH_SYSTEM_PROPERTIES, \"r\")) == NULL) {\n    // Handle error\n    printf(\"Error opening file\\n\");\n    return -1;\n}\n```\n\nIn this code, the `fopen` function is used to open a file, and the return value is checked to ensure that the file was successfully opened. If `fopen` returns `NULL`, an error message is printed and the function returns -1.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5925c749-7dbf-3038-8010-60eadb3a2ac5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if not used properly. \n\nThe `fopen` function is used to open a file, but it does not check if the operation succeeded or not. If the file does not exist or cannot be accessed for some reason, the function will return a NULL pointer, which can lead to undefined behavior if not handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the return value of `fopen` and handle the error appropriately. This can prevent undefined behavior and potential security issues.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nFILE* fd = fopen(proc_cpuinfo_path, \"r\");\nif (fd == NULL) {\n    // Handle error appropriately\n    perror(\"Error opening file\");\n    return;\n}\n```\n\nIn this fixed code, the return value of `fopen` is checked and if it is NULL, an error message is printed and the function returns.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `stdio.h`: This library is required for the `fopen` function.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8699a82-1be9-325d-a21c-4236b8ca73da",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fopen`, consider using `fopen_s` which is a safer version of `fopen`. It's also important to always check the return value of `fopen` to ensure that the file was opened successfully.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the provided code snippet:\n\n```cpp\nerrno_t err;\n\nerr = fopen_s(&fd, KFD_SYSFS_PATH_GENERATION_ID, \"r\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdio.h`: for `fopen` function\n- `errno.h`: for `errno_t` type\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2117bcff-d427-37cf-b636-5421cf45520f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the `strtok` function is used, which is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strtok`. Instead, use thread-safe alternatives such as `strtok_r` or `strtok_s`. Also, consider using higher-level string parsing functions provided by the C++ Standard Library, which are generally safer and less prone to errors.\n\n## Source Code Fix\n\nReplace the `strtok` function with a thread-safe alternative. Here's an example of how you can do this:\n\n```cpp\nchar *saveptr;\nch_ptr = strtok_r(shared_cpu_map, \",\", &saveptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "64b0ab60-1ced-322c-b8b6-eb2068181656",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the `strtok` function is used, which is not thread-safe and can lead to data races in multi-threaded programs.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strtok`. Instead, use thread-safe alternatives such as `strtok_r` or `strtok_s` if available. Also, consider using higher-level string parsing functions provided by the C++ Standard Library, which are generally safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strtok` function with a thread-safe alternative. Here is an example using `strtok_r`:\n\n```cpp\nchar *saveptr;\nch_ptr = strtok_r(NULL, \",\", &saveptr);\n```\n\n## Library Dependencies\n\nThe code example requires the C Standard Library (`<cstring>` in C++).\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e5642ce5-79ec-34d2-9d94-61c04b5b13f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5809fe15-4dd1-35b8-9bbc-b4e4bf5a6250",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate the string for you.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nprefix_len = strlen(prefix);\n```\n\nYou could use:\n\n```cpp\nprefix_len = strnlen(prefix, MAX_PREFIX_LEN);\n```\n\nWhere `MAX_PREFIX_LEN` is the maximum expected length of the prefix.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, it can lead to a buffer overflow vulnerability if the string is not null-terminated. In the provided code snippet, `strlen(shared_cpu_map)` could potentially lead to a buffer overflow if `shared_cpu_map` is not null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len = strnlen(shared_cpu_map, MAX_LENGTH);\nnum_hexs = (len + 8) / 9;\n```\n\nIn this fix, `strnlen` is used instead of `strlen` and `MAX_LENGTH` is a predefined constant that specifies the maximum length of `shared_cpu_map`.\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly indicate any library dependencies. However, the `strlen` function is part of the C Standard Library (`<cstring>` in C++).\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d5c7df64-e41e-3374-a065-10641c23a548",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the file path and handle errors properly. \n\n## Source Code Fix Recommendation\n\nHere is a safer way to open a file using C++:\n\n```cpp\n#include <fstream>\n\nstd::ifstream fileStream;\nfileStream.open(file);\nif (!fileStream) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "43cd1858-3aac-3158-a8fe-6cb41d1e44cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. If the input string is not a valid integer, it will return 0, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int debug_level = strtol(envvar, &end, 10);\nif (end == envvar || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdlib` (for `strtol()` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6d9201b9-faac-3699-b707-2be3632c3192",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if the environment variable it retrieves is controlled by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a method that validates the environment variable before using it.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string envvar;\nconst char* tmp = std::getenv(\"HSA_ZFB\");\nif(tmp != nullptr) {\n    envvar = tmp;\n}\n```\n\nIn this code, `std::getenv` is used instead of `getenv`. It also checks if the environment variable is not null before assigning it to `envvar`.\n\n## Library Dependencies\n\nThe code requires the following library dependencies:\n\n- cstdlib\n- string\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "117d0fc3-c62d-37ee-8ce0-7a0c39849d19",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to potential security risks. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or even code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a safer method to retrieve environment variables. Also, always validate and sanitize all inputs, even those coming from seemingly safe sources like environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nstd::string useSvmStr;\nchar* p = std::getenv(\"HSA_USE_SVM\");\nif(p!=NULL)\n    useSvmStr = std::string(p);\n```\n\nIn this code, we are still using `getenv` but in a safer way by checking if the returned pointer is not NULL before using it.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b3e8ea2-386b-379a-bd94-b6f7e96fd72a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to undefined behavior if the string cannot be converted to an integer.\n\n## Mitigation Advice\n\nAvoid using the `atoi()` function. Instead, use functions that perform error checking such as `strtol()`. Always validate and sanitize input before processing it. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the corrected code:\n\n```cpp\n#include <cstdlib> // for strtol and NULL\n#include <climits> // for LONG_MIN and LONG_MAX\n\nchar *end;\nlong zfb_support;\nerrno = 0;\n\nzfb_support = strtol(envvar, &end, 10);\n\nif ((errno == ERANGE && (zfb_support == LONG_MAX || zfb_support == LONG_MIN))\n    || (errno != 0 && zfb_support == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (end == envvar) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- climits\n- cstdio\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6af1b7fe-0ed1-30ec-aa8f-3e20614c5606",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is associated with the matched environment variable name. If the environment variable is controlled by an attacker, it can lead to serious security issues.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a safer function to retrieve environment variables. Validate the input and output of these functions to ensure they do not contain any malicious values.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nconst char* envvar = std::getenv(\"HSAKMT_DEBUG_LEVEL\");\nif (envvar != nullptr) {\n    // Use the value of envvar\n}\n```\n\nIn this code, we are still using `getenv()` function, but we are checking if it returns a null pointer before using the value. This can prevent null pointer dereference issues. However, this does not completely mitigate the risk if the environment variable can be controlled by an attacker.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "26278970-c011-3c6c-aecc-cf13aa48a718",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 5,
                  "endLine": 202,
                  "endColumn": 13,
                  "charOffset": 6177,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "943d24b2-b801-3716-aaa2-0158eac068aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 5,
                  "endLine": 206,
                  "endColumn": 13,
                  "charOffset": 6316,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "61c0d887-1c07-33c7-a977-4732a29ba0ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/debug.c"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 2,
                  "endLine": 532,
                  "endColumn": 57,
                  "charOffset": 14449,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                    "rendered": {
                      "text": "memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)",
                      "markdown": "`memcpy(queue_ptr, convert_queue_ids(num_queues, Queues)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/debug.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14449,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(queue_ptr, <size of queue_ptr>,  convert_queue_ids(num_queues,  Queues)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7fe858ee-ab56-38df-a52f-f24f98d3bf0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 35,
                  "charOffset": 5079,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(attrs, args->attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(attrs, args->attrs, s_attr)",
                      "markdown": "`memcpy(attrs, args->attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5079,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(attrs, <size of attrs>,  args->attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "40bcd266-2384-3785-9486-008baf1aa5fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 1,
                  "endLine": 252,
                  "endColumn": 35,
                  "charOffset": 6680,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6680,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ae7e02d7-0f9d-3fe1-90c8-595f3f1d3085",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/events.c"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 8,
                  "endLine": 247,
                  "endColumn": 14,
                  "charOffset": 6514,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fb423e8e-785a-389f-8aca-3653f0cd57fa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 14,
                  "charOffset": 2052,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "875b8707-13df-33f0-9548-f0b927d5ba5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 1,
                  "endLine": 67,
                  "endColumn": 35,
                  "charOffset": 2209,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2209,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ba3d4613-16f8-3bf9-ba24-d38657d988bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 8,
                  "endLine": 128,
                  "endColumn": 14,
                  "charOffset": 4118,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f957c67c-b0a6-3fb5-876a-30becb4cd7e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/svm.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 35,
                  "charOffset": 4275,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(args->attrs, attrs, s_attr)",
                    "rendered": {
                      "text": "memcpy(args->attrs, attrs, s_attr)",
                      "markdown": "`memcpy(args->attrs, attrs, s_attr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4275,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(args->attrs, <size of args->attrs>,  attrs,  s_attr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "867a2739-0b84-34c7-a9b3-fad7bee50348",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3817,
                  "startColumn": 1,
                  "endLine": 3818,
                  "endColumn": 34,
                  "charOffset": 111548,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                    "rendered": {
                      "text": "memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)",
                      "markdown": "`memcpy(importArgs.share_handle, SharedMemoryStruct->ShareHandle,\n\t\t\tsizeof(importArgs.share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111548,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(importArgs.share_handle, <size of importArgs.share_handle>,  SharedMemoryStruct->ShareHandle, \n\t\t\tsizeof(importArgs.share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a916fb3-03b0-3738-bffe-40b6ab7189d6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2962,
                  "startColumn": 1,
                  "endLine": 2964,
                  "endColumn": 29,
                  "charOffset": 85760,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                    "rendered": {
                      "text": "memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)",
                      "markdown": "`memcpy(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)],\n\t\t\tids_array, ids_array_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85760,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)], <size of &obj->mapped_device_id_array\n\t\t\t[obj->mapped_device_id_array_size/sizeof(uint32_t)]>, \n\t\t\tids_array,  ids_array_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a81af2e5-25e8-3122-adf3-32c8f1fdaed7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 3787,
                  "startColumn": 1,
                  "endLine": 3788,
                  "endColumn": 42,
                  "charOffset": 110495,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                    "rendered": {
                      "text": "memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)",
                      "markdown": "`memcpy(SharedMemoryStruct->ShareHandle, exportArgs.share_handle,\n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 110495,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(SharedMemoryStruct->ShareHandle, <size of SharedMemoryStruct->ShareHandle>,  exportArgs.share_handle, \n\t\t\tsizeof(SharedMemoryStruct->ShareHandle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "30cefb5e-6d04-3d68-9853-92409d953d79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2540,
                  "startColumn": 17,
                  "endLine": 2540,
                  "endColumn": 23,
                  "charOffset": 72602,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d0d81761-f442-3181-952c-25f46e587e08",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2533,
                  "startColumn": 17,
                  "endLine": 2533,
                  "endColumn": 23,
                  "charOffset": 72356,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "eca34812-b7c8-3a0e-a779-3d5eacb2aa7f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2529,
                  "startColumn": 14,
                  "endLine": 2529,
                  "endColumn": 20,
                  "charOffset": 72182,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bde0caf4-7b5e-3eea-bb45-db835b1dfd5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2042,
                  "startColumn": 1,
                  "endLine": 2043,
                  "endColumn": 34,
                  "charOffset": 56906,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                    "rendered": {
                      "text": "memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)",
                      "markdown": "`memcpy(process_apertures, args_old.process_apertures,\n\t       sizeof(*process_apertures)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fmm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56906,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(process_apertures, <size of process_apertures>,  args_old.process_apertures, \n\t       sizeof(*process_apertures)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4fa14a0a-f0d1-3d79-9459-5b6abd8fd322",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1762,
                  "startColumn": 8,
                  "endLine": 1762,
                  "endColumn": 16,
                  "charOffset": 49213,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "407d9301-f127-36b4-b584-29bfc2978455",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1073,
                  "startColumn": 8,
                  "endLine": 1073,
                  "endColumn": 14,
                  "charOffset": 30148,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3fc850f2-be94-3c63-b81f-d93e57e19f6d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 1038,
                  "startColumn": 8,
                  "endLine": 1038,
                  "endColumn": 14,
                  "charOffset": 28986,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cd5982ad-651e-3147-b69c-c88d71b409aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2523,
                  "startColumn": 16,
                  "endLine": 2523,
                  "endColumn": 22,
                  "charOffset": 71976,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "58ab4d8e-ec12-3df3-a740-b80deb4cf35b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2511,
                  "startColumn": 16,
                  "endLine": 2511,
                  "endColumn": 22,
                  "charOffset": 71506,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6cc4e82e-3221-33b2-8337-32d7759ff6a4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 549,
                  "startColumn": 11,
                  "endLine": 549,
                  "endColumn": 19,
                  "charOffset": 14844,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "48128d6d-353f-3c70-8f68-a71cdc93f5c5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fmm.c"
                },
                "region": {
                  "startLine": 2517,
                  "startColumn": 16,
                  "endLine": 2517,
                  "endColumn": 22,
                  "charOffset": 71744,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c7975da4-0f9c-3831-bddf-0ffaa2929873",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 810,
                  "startColumn": 1,
                  "endLine": 810,
                  "endColumn": 49,
                  "charOffset": 21859,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                    "rendered": {
                      "text": "memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)",
                      "markdown": "`memcpy(q->cu_mask, QueueCUMask, CUMaskCount / 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/queues.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21859,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(q->cu_mask, <size of q->cu_mask>,  QueueCUMask,  CUMaskCount / 8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "69528974-9557-3af4-b1d6-e65e3faca3c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 1,
                  "endLine": 2394,
                  "endColumn": 46,
                  "charOffset": 70810,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                    "rendered": {
                      "text": "memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)",
                      "markdown": "`memcpy(IoLinkProperties, g_props[NodeId].link,\n\t       NumIoLinks * sizeof(*IoLinkProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70810,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(IoLinkProperties, <size of IoLinkProperties>,  g_props[NodeId].link, \n\t       NumIoLinks * sizeof(*IoLinkProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3716c81a-54dd-322b-b4fa-2740a8302451",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/queues.c"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 30,
                  "endLine": 439,
                  "endColumn": 36,
                  "charOffset": 11571,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "614e7e2e-f37f-3862-ada9-97b129700396",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1634,
                  "startColumn": 6,
                  "endLine": 1634,
                  "endColumn": 11,
                  "charOffset": 49008,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8a5c755-347b-37e9-a6a0-c3cae1530489",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1533,
                  "startColumn": 6,
                  "endLine": 1533,
                  "endColumn": 11,
                  "charOffset": 45857,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "de3d036a-fa99-3cd3-b5d7-6949c6bc7e8e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1298,
                  "startColumn": 6,
                  "endLine": 1298,
                  "endColumn": 11,
                  "charOffset": 38756,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b2dc588e-a672-3c6a-8c5b-2d8baeaf3f80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1499,
                  "startColumn": 3,
                  "endLine": 1501,
                  "endColumn": 36,
                  "charOffset": 45055,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                    "rendered": {
                      "text": "memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)",
                      "markdown": "`memcpy(&tbl->cache[cache_cnt++],\n\t\t\t       this_cache,\n\t\t\t       sizeof(HsaCacheProperties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45055,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tbl->cache[cache_cnt++], <size of &tbl->cache[cache_cnt++]>, \n\t\t\t       this_cache, \n\t\t\t       sizeof(HsaCacheProperties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8d42967b-3f84-3ec3-b570-8e989712fe84",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1095,
                  "startColumn": 6,
                  "endLine": 1095,
                  "endColumn": 11,
                  "charOffset": 31141,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4891fe95-20ba-332b-bf4f-d3ac84fb5593",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 988,
                  "startColumn": 3,
                  "endLine": 988,
                  "endColumn": 45,
                  "charOffset": 28528,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                    "rendered": {
                      "text": "memcpy(cpuinfo[proc].model_name, p, p_len)",
                      "markdown": "`memcpy(cpuinfo[proc].model_name, p, p_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28528,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cpuinfo[proc].model_name, <size of cpuinfo[proc].model_name>,  p,  p_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fefc2180-ca00-3d29-806b-78df341f3d32",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 1448,
                  "startColumn": 23,
                  "endLine": 1448,
                  "endColumn": 27,
                  "charOffset": 43524,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4c0fc642-84ab-3857-b748-1f90f6652957",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 26,
                  "endLine": 997,
                  "endColumn": 30,
                  "charOffset": 28797,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "30bb7a0c-8094-306f-8808-ce7f29b60266",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 985,
                  "startColumn": 11,
                  "endLine": 985,
                  "endColumn": 20,
                  "charOffset": 28443,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28443,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91f26a41-7666-3622-9d5a-f523115909bd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 962,
                  "startColumn": 10,
                  "endLine": 962,
                  "endColumn": 14,
                  "charOffset": 27838,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cb0f06e0-f3a6-3f89-bb89-ff8d91532dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 29,
                  "endLine": 944,
                  "endColumn": 38,
                  "charOffset": 27286,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27286,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9b7fbc6f-67cb-306c-8bcd-d01ca8b8da1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 7,
                  "endLine": 941,
                  "endColumn": 16,
                  "charOffset": 27131,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27131,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "426ae88f-c755-3104-837f-fd9b0ce29c99",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 943,
                  "startColumn": 41,
                  "endLine": 943,
                  "endColumn": 50,
                  "charOffset": 27241,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27241,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ebea03cb-c3f6-371b-8288-682e5632a34d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 666,
                  "startColumn": 6,
                  "endLine": 666,
                  "endColumn": 11,
                  "charOffset": 19939,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "53ad4208-6dae-3658-9f0e-e447d212d367",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 614,
                  "startColumn": 6,
                  "endLine": 614,
                  "endColumn": 11,
                  "charOffset": 18507,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a245924f-4407-3779-9db4-e8cb4ceb6389",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 10,
                  "endLine": 919,
                  "endColumn": 14,
                  "charOffset": 26617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e226928f-9961-33b5-9e79-3fc4fe5cae72",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 723,
                  "startColumn": 6,
                  "endLine": 723,
                  "endColumn": 11,
                  "charOffset": 21212,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5925c749-7dbf-3038-8010-60eadb3a2ac5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 6,
                  "endLine": 898,
                  "endColumn": 11,
                  "charOffset": 25994,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8699a82-1be9-325d-a21c-4236b8ca73da",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 584,
                  "startColumn": 6,
                  "endLine": 584,
                  "endColumn": 11,
                  "charOffset": 17750,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2117bcff-d427-37cf-b636-5421cf45520f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 468,
                  "startColumn": 10,
                  "endLine": 468,
                  "endColumn": 16,
                  "charOffset": 14048,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "64b0ab60-1ced-322c-b8b6-eb2068181656",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 483,
                  "startColumn": 11,
                  "endLine": 483,
                  "endColumn": 17,
                  "charOffset": 14479,
                  "charLength": 6,
                  "snippet": {
                    "text": "strtok",
                    "rendered": {
                      "text": "strtok",
                      "markdown": "`strtok`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e5642ce5-79ec-34d2-9d94-61c04b5b13f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 6,
                  "endLine": 395,
                  "endColumn": 11,
                  "charOffset": 12280,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5809fe15-4dd1-35b8-9bbc-b4e4bf5a6250",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 372,
                  "startColumn": 6,
                  "endLine": 372,
                  "endColumn": 11,
                  "charOffset": 11767,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b16d0e6d-af7c-3814-9df2-75226d67a67b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 18,
                  "endLine": 344,
                  "endColumn": 32,
                  "charOffset": 11181,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(prefix)",
                    "rendered": {
                      "text": "strlen(prefix)",
                      "markdown": "`strlen(prefix)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11181,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7b9dfa8f-5075-338d-85ae-aca45dcb8c97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 13,
                  "endLine": 467,
                  "endColumn": 35,
                  "charOffset": 13980,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(shared_cpu_map)",
                    "rendered": {
                      "text": "strlen(shared_cpu_map)",
                      "markdown": "`strlen(shared_cpu_map)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13980,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(shared_cpu_map, <size of shared_cpu_map>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d5c7df64-e41e-3374-a065-10641c23a548",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/topology.c"
                },
                "region": {
                  "startLine": 420,
                  "startColumn": 6,
                  "endLine": 420,
                  "endColumn": 11,
                  "charOffset": 12834,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "43cd1858-3aac-3158-a8fe-6cb41d1e44cb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 16,
                  "endLine": 135,
                  "endColumn": 20,
                  "charOffset": 3617,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6d9201b9-faac-3699-b707-2be3632c3192",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 10,
                  "endLine": 142,
                  "endColumn": 16,
                  "charOffset": 3824,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "117d0fc3-c62d-37ee-8ce0-7a0c39849d19",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 14,
                  "endLine": 196,
                  "endColumn": 20,
                  "charOffset": 5074,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b3e8ea2-386b-379a-bd94-b6f7e96fd72a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 20,
                  "charOffset": 3872,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6af1b7fe-0ed1-30ec-aa8f-3e20614c5606",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/openclose.c"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 10,
                  "endLine": 133,
                  "endColumn": 16,
                  "charOffset": 3556,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}